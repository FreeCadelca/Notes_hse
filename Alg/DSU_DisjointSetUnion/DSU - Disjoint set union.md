# Постановка задачи

Представим, что нам нужно объединять какие-то объекты в какие-то множества. Причем нельзя сказать, что мы просто создаем множества и со временем заполняем их. Возможна такая ситуация, что нам придется "слить" ранее созданные множества в одно, и это будет сложно (долго) сделать, если множества у нас работают как контейнеры. 

Можно провести аналогию с капельками на стекле (представленной в виде декартовой системе координат). Представим, что капельки сливаются, если между ними меньше двух сантиметров. 
Мы капнули первую капельку в точку (1, 1), вторую капельку в точку (3, 3), третью - в (4, 4), четвертую - в (2, 2). 
После того, как мы капнули третью капельку, образовалась большая длинная капля, растянувшаяся с координаты (3, 3) до (4, 4) (потому что расстояние = 1,41 см < 2 см, они слились в одну).
После того, как мы капнули четвёртую капельку, образовалась огромная колбаса из всех накапанных капелек - с (1, 1) до (4, 4), потому что последняя капля стала "мостиком" между первой каплей и длинной каплей из прошлого пункта ((3, 3) - (4, 4)), поэтому она "слила" все капли в одно множество. Как же можно быстро решать эту задачу бесконечных множеств и сливаний? 

---

# Описание структуры и общая концепция

Пусть есть N элементов, пронумерованных от 0 до N-1 со следующими свойствами 
- Некоторые группы чисел объединены в множества
- Мы можем добавить в структуру новый элемент и он станет новым множеством
- Можно слить два множества в одно

Внутри этой структуры будут следующие ключевые операции:
- *MakeSet(x)* - создать в структуре новое множество из элемента `x`
- *Find(x)* - вернуть идентификатор множества, к которому относится элемент `x` (идентификатор - это номер представителя множества). Для разных элементов одного множества будет один и тот же результат Find
- *Unite(x, y)* - объединить множества, в которых лежат `x` и `y` 

![](./Materials/DSU%20-%20Disjoint%20set%20union-1758804967441.jpeg)

---

# Реализация в программировании

Хранить структуру будем в виде леса - непересекающихся (не связанных) деревьев, тогда:
- Все элементы одного множества будут лежать в одном дереве
- Корень - представитель множества
- Слияние - объединение двух деревьев

Для начала заведём массив `p`, хранящий предка для каждой вершины (в `p[i]` лежит номер предка для элемента с номером `i`). Для корня предок - он сам.

С уже таким маленьким набором можно написать реализацию двух основных функций - MakeSet(x) и Find(x).

### MakeSet(x):

```
void MakeSet(int x){
	p[x] = x;
}
```

### Find(x):

Тут уже сложнее.
Для поиска представителя просто будем подниматься по предкам вверх, пока не 
дойдём для корня. Мы поймём, что это корень, когда предок элемента будет он же сам.
Однако в худшем случае наше дерево может выродиться в одну длинную ветку длинной `n`, тогда сложность поиска будет `O(n)`. Здесь появляется первая эвристика нашего алгоритма (**path compression**):

> Давайте просто не допускать чрезмерно длинных веток дерева. Будем время от времени (при каждом вызове Find) сжимать пути там, где проходимся.

Таким образом за один проход по предкам при вызове Find(x) мы будем 'переподвешивать' все вершины на пути к корню за этот же корень, чтобы в дальнейшем мы уже знали ответ. Реализация операции Find окажется *двухпроходной*

Рассмотрим на примере:

![](Materials/DSU%20-%20Disjoint%20set%20union-1758819426924.jpeg)

Вызвав `Find(3)` мы запустим рекурсию, которая пойдёт по красным стрелкам к корню и перезапишет массив предков (переподвесит) так, что элементы будут напрямую предками корня, в итоге глубина дерево значительно снизится, так как после одного прохода оно амортизируется до состояния третьей схемы на рисунке.

```
int Find(int x) {
	// Если это корень - то сразу возвращаем его же
	if (p[x] == x) return x;
	// Иначе перецепляем эту вершину за корень. Рекурсия не только даст ответ (придет к корню), но и за нас перецепит все вершины на пути к корню (уменьшит дерево)  
	p[x] = Find(p[x]);
	return p[x];
}
```

### Unite(x, y):

Операцию слияния реализовать уже сложнее. Разобьем её на несколько этапов:
1. Найдём корни двух сливаемых элементов (`x`, `y`). Мы получили представителей (корни) двух множеств, которые мы должны объединить.
2. Если корни совпали, то элементы и так находятся в одном множестве, ничего объединять не надо.
3. Если корни не совпали, то подвесим корень одного дерева в качестве веточки к корню другого (просто скажем, что теперь предок для корня одного дерева отныне - корень другого дерева).

Однако встаёт хороший вопрос: как выбрать, какое дерево цеплять к какому во втором пункте? 
Здесь появляется вторая эвристика данной структуры:

> Давайте также хранить размер дерева и называть это рангом (или размером) множества. Тогда при объединении деревьев будем цеплять маленькое дерево к большому (при равенстве не имеет значения)

Для этого заводим еще один массив - `size[n]`, в котором будем хранить размер множества (дерева), а точнее - размер поддерева с корнем в вершине `x`. 

Это не так сложно, как кажется. Зададимся парой вопросов: 
- Подумаем, когда вообще может меняться размер множества?  - Только при слиянии с другим множеством. Сами подумайте - операция `Find(x)` не меняет дерево, операция `MakeSet(x)` вообще инициализационная (старотовая) для каждого нового множества и в ней нужно задавать начальный размер = 1, остаётся только Union
- А на сколько меняется размер деревьев при слиянии друг с другом? Для определённости положим, что дерево с вершиной `y` меньше дерева с вершиной `x`, в противном случае просто поменяем их местами.
	- То дерево, ***которое*** крепят (оно меньше, для определенности скажем, что это дерево с вершиной `y`), не меняет размер своего поддерева, туда не добавляются новые вершины, скорее, она сама крепится как вершина целиком
	- Дерево, ***к которому*** крепят новое (`x`), меняет размер, увеличиваясь ровно на размер этого нового поддерева (`size[x] = size[x] + size[y];`)
Получается, мы обновляем размер только при слиянии, причем только у большего дерева и увеличиваем на размер присоединяемого дерева.

Теперь, когда продумали все этапы операции слияния и сошлись на конкретном порядком присоединения деревьев, а также процедурой обновления размеров, можем написать реализацию

```
void unite(int x, int y) {
	// Ищем представителей множеств (корни)
	x = find(x);
	y = find(y);
	
	// Если элементы и так в одном множестве - ничего не делаем
	if (x == y) return;
	
	// Если размеры деревьев в неправильном порядке (нам нужно x > y), свапаем деревья
	if (size[x] < size[y]) swap(x, y);
	
	// Перецепляем дерево y (говорим, что теперь у `y` предок - `x`)
	parent[y] = x;
	// Обновляем размер дерева `x`
	size[x] += size[y];
}
```

### Итоговая реализация:

Переписав всё в структуру на языке C++, получается вот такая готовая реализация (я сделал без операции MakeSet, заменив ее на инициализацию структуры, в которой сразу создаю n множеств размера 1 для всех n элементов):

```
struct DSU {
    vector<int> parent;
    vector<int> size;

	// n - размер всех элементов, объектов. Заранее создадим все множества, состоящие из одиночных элементов, n разных множеств размера 1. Далее будем их только объединять
    DSU(int n) {
        parent.resize(n);
        size.resize(n, 1);
        for (int i = 0; i < n; i++) parent[i] = i;
    }
	
    int find(int x) {
		if (p[x] == x) return x;
		p[x] = Find(p[x]);
		return p[x];
    }

    void unite(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) return;
        if (size[x] < size[y]) swap(x, y);
        parent[y] = x;
        size[x] += size[y];
    }
};
```

---

# Упрощённый вариант без массива size

Однако если мы не хотим заморачиваться с размерами множеств ***и они нам не нужны в задаче***, то можно определять порядок присоединения деревьев случайным образом. Практика показывает, что такая "ленивая" реализация тоже хорошо себя показывает, не сильно уступая оригинальному ранговому.

Я не стал писать функцию рандома, поэтому просто буду цеплять `y` к `x`, это тоже сработает

```
void unite(int x, int y) {
	x = find(x);
	y = find(y);
	
	if (x == y) return;
	parent[y] = x;
}
```

---

# Сложность

В силу применения двух эвристик скорость работы каждой операции сильно зависит от структуры дерева, а структура дерева — от списка выполненных до того операций. Исключение составляет только `MakeSet` — её время работы очевидно `O(1)`. Для остальных двух скорость очень неочевидна.

Роберт Тарьян доказал в 1975 г. замечательный факт: время работы как `Find`, так и `Unite` на лесе размера `N` есть `O(α(N))`. (Это очень и очень быстро, быстрее, чем логарифм, объяснение ниже) 
Под `α(N)` в математике обозначается *обратная функция Аккермана*, то есть, функция, обратная для `f(N) = A(N, N)`. [Функция Аккермана](http://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_%D0%90%D0%BA%D0%BA%D0%B5%D1%80%D0%BC%D0%B0%D0%BD%D0%B0) `A(N, M)` известна тем, что у нее колоссальная скорость роста. К примеру, $A(4, 4) = 2^{2^{2^{65536}}}-3$, это число поистине огромно. Вообще, для всех мыслимых практических значений N обратная функция Аккермана от него не превысит 5! Поэтому её можно принять за константу и считать O(α(N)) ≅ O(1).  
  
Итак, имеем:  
- MakeSet(X) — O(1).  
- Find(X) — O(1) (амортизированно).  
- Unite(X, Y) — O(1) (амортизированно).  
- Расход памяти — O(N).