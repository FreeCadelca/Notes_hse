теперь я пытаюсь объяснить

в работе используются 2 массива - symbols_array и symbols_array_tmp. Первый нужен для отображения на плате (он размером 6 символов = 6\*5 бит), второй хранит всю строку с символами и делает смещение в состоянии SHIFT. 
(P.s. индексы в verilog идут справа налево, little endian, не как обычные массивы в других языках)
Проблема в том, что symbols_array_tmp не сразу записывает в себя всю строку. Изначально он заполнен бланками (пробелами), а потом записывает в конец(или начало) следующий символ из отображаемой строки (string_to_display), далее - сдвигает в нужную сторону всю строку, тогда пробел или уже существующий символ вылезет с другой стороны и потом либо заменится на себя же (если строка пробегала один раз полностью и symbols_array_tmp уже заполнился), либо начальный пробел замениться на правильный символ. 

Еще одна проблема - symbols_array меньше symbols_array_tmp, поэтому мы "пихаем" в массив отображения не все символы, а срез из symbols_array_tmp. Другой вопрос - какой срез? Какая часть массива? В начальной реализации там берется правый срез, поэтому в случае с бегущей строкой влево (как изначально в присланной лабе было) это будет классно и без задержки, первые же символы начинают отображаться, но когда мы меняем направление на "слева-направо", то символы начинают "появляться" уже не справа, а слева. В таком случае правый срез массива symbols_array_tmp заполняется не сразу, а ближе к концу, отсюда и задержка (пока пробегут несколько символов до этого среза, пройдет 5-6 тактов). Решение - при направлении строки слева направо мы будем брать срез с левой части массива symbols_array_tmp, тогда первые же символы сразу покажутся без задержки