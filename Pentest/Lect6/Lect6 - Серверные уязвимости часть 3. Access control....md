![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759667427039.jpeg)

# Access control

> Контроль доступа - это применение ограничений касательно того, кто или что имеет право выполнять действия или получать доступ к ресурсам

- Аутентификация подтверждает, что пользователь тот, за кого он себя выдаёт
- Контроль сессий принадлежность конкретных запросов к пользователю
- Контроль доступа определяет, может ли пользователь выполнить то или иное действие

Проблемы контроля доступа называются **Broken Access Control** (A01:2021 OWASP)

![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759679551151.jpeg)

> **Модель контроля доступа** - это формально определённый набор правил контроля доступа, который не зависит от технологии или платформы реализации. Модели безопасности контроля доступа реализуются в операционных системах, сетях, системах управления базами данных и т.д.

Основные типы включают:
- Программный контроль доступа
- Дискреционный контроль доступа (DAC)
- Мандатный контроль доступа (MAC)
- Управление доступом на основе ролей (RBAC)

### Программный контроль доступа

При программном управлении доступом матрица привилегий пользователя хранится в базе данных или аналогичном объекте, а элементы управления доступом применяются программно со ссылкой на эту матрицу.
Этот подход к контролю доступа может включать роли, группы или отдельных пользователей, коллекции или рабочие процессы процессов и может быть очень детализированным.
### Дискреционный контроль доступа (DAC)

> **Дискреционный контроль доступа (DAC)** - доступ к ресурсам или функциям ограничен на основе пользователей или именованных групп пользователей. Владельцы ресурсов или функций могут назначать или делегировать права доступа пользователям.
- Область применения: ОС, файловые системы...
- Плюсы: гибкость и простота для небольших групп, удобство для пользователя
- Минусы: слабая безопасность, уязвимость к ВПО (вредоносное ПО), не подходит для строгих политик безопасности

![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759679936221.jpeg)

### Мандатный контроль доступа (MAC)

> **Мандатный контроль доступа (MAC)** - модель, к которой права доступа назначаются централизованно системой на основе строгих правил (с использованием меток). Пользователь не может их изменить
- Область применения: гос. и военные структуры, организации со строгими требованиями к защите данных
- Плюсы: высокая безопасность, централизованное управление
- Минусы: не гибкая, сложная в администрировании, неудобная для пользователей

![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759680031917.jpeg)

### Bell LaPadula VS BiBa (в MAC)

![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759680080112.jpeg)

### Управление доступом на основе ролей (RBAC)

> Управление доступом на основе ролей (RBAC) - определяются именованные роли, которым назначаются права доступа. Затем пользователям назначается одна или несколько ролей
- Область применения: подавляющее большинство бизнес приложений (ERP, CRM-системы), корпоративные сети, бд.
- Плюсы: упрощенное администрирование, принцип минимальных привилегий, соответствие структуре организации
- Минусы: не гибкая в исключениях, сложность первоначальной настройки, "вздутие ролей"
- Является наиболее эффективным способом разграничения доступа

Вздутие ролей - концепция, когда роль становится огромной, либо ролей становится очень много

### Виды контроля доступа

- Вертикальный контроль доступа - ограничение пользователей от чувствительных данных приложения и действий, требующих более высокий уровень привилегий
- Горизонтальный контроль доступа - ограничение пользователей от данных других пользователей
- Контeкстно-зависимый контроль доступа - ограничение на основе состояния приложения (напр. от неправильной последовательности действий)
- Контроль доступа на основе локации (географический)

### Возможное влияние 

- Повышение привилегий в приложении: верт/гор
- Insecure Direct Object Reference (iDOR)
- Нарушение последовательности действий

### Вертикальное повышение привилегий: примеры

- Отсутствие ограничений доступа к панели администратора
- Попытка ограничения доступа на основе обфускации названий
- Контроль доступа к административной функциональности при помощи параметров, подконтрольных пользователю
- Возможность смены собственной роли (Mass Asignment - изменяя одни поля, мы можем изменить другие)
- Мисконфиг веб сервера (X-Original-URL, X-Rewrite-URL)
- Обход контроля доступа на основе метода запроса (POST -> GET)
- Обход контроля доступа путём эксплуатации разногласий интерпретации URL (/aDmiN)

![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759689890382.jpeg)

### Горизонтальный elevation

- Управление идентификаторами пользователей
- Попытка ограничения доступа на основе непредсказуемых идентификаторов пользователей (напр. UUID)
- Раскрытие информации приложением

При горизонтальном повышении привилегий на пользователя с большими привилегиями будет реализовано также вертикальное повышение привилегий

![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759690842041.jpeg)

### Insecure Direct Object Reference (IDOR)

- Тип уязвимости контроля доступа, возникающий, когда приложение использует данные, предоставленные пользователем, для прямого доступа к объектам. Подкласс BAC
- Уязвимости IDOR чаще всего связаны с горизонтальным повышением привилегий, но могут возникать и при вертикальном повышении привилегий
- В отличие от BAC, в IDOR пользователь легально имеет доступ к функциональности, но получает доступ к чужому объекту
- Устранение уязвимости строится на проверке возможности доступа пользователя к конкретному ресурсу, а не полном отключении функциональности

https\://example.com/?page\===1337==.pdf
https\://example.com/order/==1337==/info

Простыми словами, IDOR - уяза, когда можно в URL указать другое число и тебе разрешат читать другой объекь (вышкинский антиплагиат)

### Нарушение последовательнности действий

- В современных приложениях многие действия происходят по цепочке операций
- Например, подтверждение заказа администратором магазина:
	1. Получение информации по заказу
	2. Проверка и возможное изменение данных
	3. Уточнение и возможное изменение данных
	4. Выставление финального вердикта
- На первых этапах контроль доступа будет качественный почти всегда
- В остальных этапах он может быть пропущен из-за предположения о целостности последовательности действий

![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759691017604.jpeg)

### Referrer-based Access Control

- Контроль доступа на основе заголовка Referrer
- Пример: приложение видит /admin/* в Referrer, значит пользователь до этого посещал раздел администратора, значит имеет право его посещать
- Очень легко обходится, но трудно детектируется черным ящиком
- Также редко встречается

Referrer: https\://example.com/==admin/dashboard==

### Способы тестирования приложений с большим количеством ролей

- В простых приложениях обычно существуют 2-3 различные роли
- Однако, чем сложнее приложение, тем их может быть больше: 10, 20..
- Автоматические инструменты плохо справляются с обнаружением уязвимости класса BAC
- Облегчить жизнь могут расширения Burp Suite: Authorize, Auth Analyser, AuthMatrix
- Идея в сохранении нескольких сессий и одновременная проверка запросов с использованием каждой из побочных сессий . Дальнейший анализ проводится вручную

![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759691114447.jpeg)

### Контроль доступа: защита

- Не полагаться только на обфускацию при реализации контроля доступа
- Ограничивать побличный доступ к разделам до тех пор, пока это явно не потруется
- Использовать единый механизм контроля доступа на все приложение
- Четко продумывать необходимые права доступа на уровне разработки
- Ограничивать доступ по умолчанию (zero-trust идеология)
- Тщательно проводить аудит механизмов контроля доступа

#  Server side request forgery (SSRF)

> **Open Redirect** - это ***клиентская*** уязвимость, позволяющая атакующему перенаправить пользователей на произвольные ресурсы

![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759691261193.jpeg)

> **SSRF** - это уязвимость веб-безопасности, которая позволяет злоумышленнику заставить ***серверное приложение*** отправлять запросы в непреднамеренное место

![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759691475806.jpeg)

Как это может выглядеть в коде:

Python:
```
@app.route('/fetch')
def fetch():
url = request.args.get('url')
return requests.get(url).content
```

Php:
```
<?php
$url = $_GET['url'];
$data = file_get_contents($url);
echo $data;
?>
```

Пример из реальной жизни:

![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759691532690.jpeg)

![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759691549545.jpeg)

![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759691575455.jpeg)

### Возможное влияние

- Обход контроля доступа в приложении
- Злоупотребление правами доступа внутренних сервисов
- Сканирование портов
- Чейны с другими уязвимостями (например, доставка XSS)
- Обычно имеет высокую критичность
- RCE
- DoS

### Обход контроля доступа в приложении

- производится запрос к localhost приложения. В некоторых случаях происходит обход контроля доступа.

![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759691626446.jpeg)

POST /view/url HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: XXX
url\===http\://localhost/admin==

### Злоупотребление правами доступа внутренних сервисов

- Производится запрос к ip внутреннего приложения
- Обычно там выстроено доверие и запрос принимается без проблем
- Сложно обнаружить и эксплуатировать из внешней сети

![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759691759690.jpeg)

POST /view/url HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: XXX
url\===http\://10.0.0.3/execute?cmd=whoami==

### Популярные методы защиты

- Черные списки
- Белые списки
- Изменение логики
- SSRF Proxy

### Обход черных списков

- Альтернативные представления IP (+IPv6)
	- 127.0.0.1 -> 2130706433, ...

	![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759691832063.jpeg)

- Зарегистрировать доменное имя, указывающее на 127.0.0.1 или использовать готовые (spoofed.burpcollaborator.net)
- Обфускация символов (URL-encode, case variation): `locAlHpST`
- Использовать подконтрольный ресурс, перенаправляющий в нужное место (Redirect)

![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759691864358.jpeg)

### Обход белых списков

- Использование формата представления УЗ: `http://expected.host:something@evil.host`
- Использование символа #: `http://evil.host#expected.host`
- Регистрация доменного имени (с поддоменом): `http://expected.host.evil.host`
- URL-encodem double URL-encode
- Использовать Open Redirect
- Использовать комбинации вышеназванных техник
- DNS Rebinding

https://portswigger.net/web-security/ssrf/url-validation-bypass-cheat-sheet

![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759691970606.jpeg)

### Виды SSRF

##### Видимые

- Атакующий может видеть ответ от внутреннего сервиса
- Ценится и имеет критичность выше
- При возможности нужно стремиться приводить слепую SSRF к видимой

##### Cлепые (Blind)

- Атакующий не имеет возможности видеть ответ от внутреннего сервера
- Сложнее эксплуатировать
- Ценится и имеет критичность ниже
- Можно обнаружить попыткой инициирования соединения к подконтрольному серверу
- Внешние HTTP-запросы скорее всего будут заблокированы. Можно использовать DNS и иные протоколы (FTP)
- Также можно обнаружить временными задержками

### RCE в SSRF

- Инъекция команд в URL: `http://evil.host?c='whoami'`
- Использование (древнего) протокола gopher:// (Gopherus)

### Необычные места появления SSRF

- Праметр kid в JWT
	```
	{
	"kid":"http://127.0.0.1/admin?upgrade=username",
	...
	}
	```
- Передача части подконтрольного URL в запросе
- Перевод в нестандартные форматы данных (-> XML -> XXE)
- Заголовок Referrer (иногда используется для аналитики)
- Поле Server Name Indication (SNI) SSL-сертификата: 
	`openssl s_client -connect target.com:443 -servername "internal.host.com" -crlf`
- Рендер pdf

### Cheatsheats

- https://portswigger.net/web-security/ssrf/url-validation-bypass-cheat-sheet
- https://www.thehacker.recipes/web/inputs/ssrf/
- https://book.hacktricks.wiki/en/pentesting-web/ssrf-server-side-request-forgery/index.html

# Race Conditions

> **Race Conditions (состояние гонки)** - распространённый тип уязвимости, тесно связанный с недостатками бизнес логики Они возникают, когда веб приложения обрабатывают запросы одновременно без релевантных мер защиты. Это может привести к одновремененному взаимодействию нескольких отельных потоков с одними и темит же данными, что приводит к коллизии, вызывающей непреднамеренное поведение приложения. Атака на состояние гонки использует тщательно рассчитанные по времени запросы для преднамеренной коллизии и использования этого непреднамеренного поведения во вредоносных целях

> Race window - когда отсылаем запросы, есть миллисекундное окно, когда возможен одновременный доступ к ресурсу. Данный промежуток называется **race window (временное окно)**

![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759692364224.jpeg)

### Race conditions: влияние

Самое разнообразное, сильно зависит от логики приложения. В наиболее интересных (но крайне редких) кейсах может привести к удаленному исполнению кода (RCE). Чаще всего может использоваться для обхода блокировок и логики (например, множественный перевод денег с карты банка)

### Классификации Race Conditions:

| **По типу**          | **По способу эксплуатации** | **По месту применения** |
| -------------------- | --------------------------- | ----------------------- |
| Limit Overrun        | Классические                | Single-Endpoint         |
| State Changes        | HTTP/2                      | Multi-endpoint          |
| Resourse Access      |                             |                         |
| Partial Construction |                             |                         |

### Limit Overrun

- Наиболее известный тип
- Суть - произведение большого кол-ва действий, чем заложенно логикой
- Пример:
	- Использование купона на скидку
	- Перевод денег
	- Проставление оценки товару
	- Переиспользование CAPTCHA
	- Обход ограничений при bruteforce-атаках

Нормальный запрос без атаки:

![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759692613471.jpeg)

Ловля временного окна и реализация race conditions:

![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759692640888.jpeg)

### State changes

На протяжении своей работы приложение часто меняет состояния
В некоторых случаях данный процесс не заметен
- Суть: обход состояния во время нормальной работы приложения
- Пример: мультифакторная аутентификация

![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759692816172.jpeg)

### Resource access

- Суть: доступ к общему ресурсу во время его использования другим процессов
- Пример: загрузка ВПО и получение к нему доступа во время анализа антивирусным ПО

![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759692881855.jpeg)

### Partial construction Race conditions

- Многие приложения создают объекты в несколько этапов
- Например, создание пользователя и сущностей, принадлежащих ему в несколько SQL-ззапросов
- Между этими этапами существует небольшое временное окно, когда данные не инициализированы
- Неинициализированные данные имеют значения по умолчанию
- Во временное окно возможно воспользоваться значением по умолчанию

![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759692958893.jpeg)

### Главная проблема эксплуатации Race Conditions

В эксплуатации race conditions мы сталкиваемся с проблемой задержек. Дело в том, что задержка не всегда постоянная и какую-то ее часть мы банально не можем контролировать и отследить

![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759692974027.jpeg)

Network latency - задержка сети. Можно высчитать точно, будет примерно всегда одна и та же

Jitter - вторичное колебание задержки, зависящее от внешних факторов, никак не контролируется и не высчитывается, можно сказать, случайное

Internal latency - время работы программы до нужной строки кода внутри приложения

### Методы решения

- Классические Race conditions
	- Last-byte synchronisation
	1. Происходит отправка нескольких запросов с удержанием последнего байта
	2. Последние байты всех запросов отправляются одновременно
	3. Сервер ждет окончания запросов и испытывает состояние гонки от одновременных запросов

- HTTP/2
	- Несколько запросов отправляются внутри одного

	![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759693165199.jpeg)

### Практическая эксплуатация

![](./Materials/Lect6%20-%20Серверные%20уязвимости%20часть%203.%20Access%20control.-1759693195417.jpeg)

### Single-endpoint и Multi-endpoint Race Conditions

| Single-endpoint                                             | Multi-endpoint                                                                                                                                 |
| ----------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| - Race-запросы отправляются к одной и той же конечной точке | - Race-запросы отправляются к разным конечным точкам                                                                                           |
| - Требуют идеального попадания в момент времени             | - Более интуитивный сценарий                                                                                                                   |
| - Пример: одновременный запрос                              | - Имеет дополнительное время задержки (не только из-за сети (новое соединение), но также из-за разного времени работы разных функциональностей |

### Варианты обхода задержек в Multi-endpoint race conditions

- "Разогрев" соединения: перед эксплуатацией делается любой запрос к приложению, чтобы минимизировать дальнейшие сетевые задержки
- Планирование запросов: происходит конфигурация задержек на стороне клиента перед отправкой race-запросов. Конкурирующие запросы отправляются в разное время. Минусы: крайне сложно угадать нужную задержку, не получится использовать single-packet attack
- Злоупотребление ресурсами: сервер заполняется кучей бесполезных запросов, чтобы создать внутри него очередь. Дальнейшие запросы будут разбираться после задержки. Задержка сервера может обеспечить необходимое временное окно


### Защита

- Избегать смешивания данных из разных источников
- Использовать атомарные изменения состояний для чувствительных конечных точек (меньше параллелизма, одиночные транзакции)
- Использовать механизмы уникальности (например, уникальности в БД)
- Не использовать один уровень хранения данных, чтобы обезопасить другой
- Использовать безопасные фреймворки, поддерживающие консистентность (согласованность) данных
- Если позволяет архитектура, полностью отказаться от состояния на стороне сервера