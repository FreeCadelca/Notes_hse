![[Materials/Pasted image 20250913111723.jpeg]]

### Клиент и сервер

Клиент-серверная архитектура
Клиент: потребитель информации
- Веб-браузер
- Консольное приложение
- ПО
- др
Сервер:
- производитель информации

Какой минимальный набор нужен для сайта? - веб серсер и статический контент

### Приложение, веб сервер и веб-сайт

Различия:

Приложение(повар):
- реализует логику (язык программирования)
- обрабатывает данные
- взаимодействует с окружением (бд)
- производит динамический контент 

Веб-сервер (официант)
- обрабатывает запрос клиента
- понимает, куда нужно доставить запрос в приложении
- доставляет статический контент

Клиент:
статический контент (столовые приборы)

Веб-сайт может быть статическим (страничка), веб-приложение обязательно с поваром

Веб-приложение без статического контента - API или генерирует статический контент на лету

Веб-сервера:
- nginx
- apache
- microsoft iis
- caddy
- tomcat
- ...

Популярные связки:

- Nginx + py (django, flask, fast api)
- Nginx + Node.js (express/nest js)
- Apache + php
- ...



### HTTP

протокол прикладного уровня

запрос-ответ

минимальный запрос:
```
GET/HTTP/1.1
Host: example.com


```
Метод - GET
Путь - /
Версия - HTTP/1.1
Хост - host...
две строки

Коды ответа
xyy
x - класс кода ответа
yy - номер в классе

1xx - информационные
100 - continue
101 - switching protocols

2xx - коды успеха
200 - ok
201 - created

3xx - перенаправления
301 - moved permanently
302 - found

4xx - ошибки на стороне клиента
401 - unautorized 
403 - forbidden

5xx - ошибки на стороне сервера
500 - internal server error
504 - gateway timeout

методы http:
![[Materials/Pasted image 20250913112901.jpeg]]

идемпотентный метод - если ввели несколько раз, то результат не изменится

путь - позволяет серверу понять, что именно грузить

HTTP Routing types
File system Routing
1. Фиксируется web root /var/www/html)
2. Файлы приложения помещаются физически на файловую систему (в путь)
3. При обращении происходит адрессация к конерктному файлу)

Annotation-Based Routing (decorator routing)
- Пути декларируются в декораторах соответствующих классов/функций
![[Materials/Pasted image 20250913113402.jpeg]]

Code-based/Imperative Routing
- Пути декларируются напрямую в коде
![[Materials/Pasted image 20250913113514.jpeg]]

Servlet mappings (java servlet api)
- Имеется специальный xml-файл, который определяет соответствие путей обработчикам (Servlet)
![[Materials/Pasted image 20250913113504.jpeg]]

Configuration-File Routing
- Имеется файл-конфигурация, определяющая соответствие пути и класса/функции
![[Materials/Pasted image 20250913113621.jpeg]]

Convention-Based Routing
- Пути наследуются исходя из названий (/users/show/:id запустит метод show класса UsersController)

**Версия**
- определяет формат, в котором были отправлены данные

Http/0.9
- совсем древний, только get метод
- нет заголовков

http/1.0
- древний, но где-то встречается
- методы head, post
- заголовки
- типы контента
- коды состояния 
- всего одно соединение на объект

Http/1.1
- старый, но доминирует
- появилась возможность не обрывать запрос
- обязательный заголовок host
- появилось кеширование, сжатие, чанкование
- новые коды состояния
- методы PUT, DELETE, TRACE
- проблема: головная блокировка (Head-of-Line Blocking - HOL), медленный ответ на первый запрос в конвейере, блокирует все последующие в очереди

HTTP/2
- широко используется, но пока не победил 1.1
- Бинарный протокол
- мультиплексирование (параллельная отправка запросов в рамках одного tcp-тунеля)
- приоритизация запросов (js > картинки)
- сжатие заголовков
- возможность отправить объекты до того, как их запросили
- Проблема: HOL на уровень ниже, если один tcp-пакет потеряется, весь потом заблокируется

HTTP/3
- Активно внедряется
- Использует QUIC вместо TCP
- встроенное шифрование
- очень быстрый
- умеет быстро переключаться между сетями
- проблема: нужна и на сервере, и на клиенте

**Параметры** - позволяют передать что-то серверу
способы
1. GET запрос - ?user=hacker&theme=dark
2. GET-запрос RESTful-сервиса - /hacker/dark - пишутся в пути
3. POST-запрос - после заголовков через отступ: ?user=hacker&theme=dark

**Заголовки**
передают спец информацию (метаданные)

ключевые заголовки:
- cookies
	- имеют меньший размер (~45кб)
	- автоматически отправляются при каждом запросе
	- доступны из JS, но это можно ограничить флагами безопасности
	- имеют 3 флага безопасности: httpOnly, Secure, SameSite
	- время жизни регулируется
	- отправляются заголовком Cookie:
- LocalStoarge
	- имеют больший размер (5-10мб)
	- никогда не отправляются автоматически
	- всегда доступны из Js
	- нет лимита времени жизни
	- отправляются заголовком Autorization
- SessionStoarge
	- то же самое, что LocalStoarge, но активна, пока открыта вкладка браузера (лимит жизни)
хранятся в Application -> Stoarge -> \<stoarges\>
- Host - указывает доменное имя, порт сервер
- Content-Type - указывает MIME-тип тела запроса
- Content-Length - Указывает размер тела HTTP-сообщения в **байтах**
- Refer - указывает URL предыдущей страницы
- Origin - указывает origin источника запроса (для CORS)
- User-Agent - Идентифицирует клиентское ПО (браузер, ОС)
- X-Forwarded-For (XFF) - Используется прокси для указания реального IP клиента
- Transfer-Encoding - Используется для указания формата отправки тела запроса
- Location - Заголовок ответа. Указывает URL для перенаправления (в ответах 3xx)
- Content-Security-Policy (CSP) - Заголовок ответа. Регулирует правила загрузки скриптов, фреймов, прочего контента (Content-Security-Policy: default-src 'self';)

**Прокси-сервер**

![[Materials/Pasted image 20250913115343.jpeg]]

первоначально мы можем делать запрос к прокси-серверу, потом он перенаправляет нас на виртуальные хосты

![[../Lect1/Materials/Pasted image 20250913102301.jpeg]]

Также используется как балансировщик нагрузки
![[Materials/Pasted image 20250913115502.jpeg]]

Терминация SSL/TLS
![[Materials/Pasted image 20250913115700.jpeg]]

Кеширование
![[Materials/Pasted image 20250913115751.jpeg]]

Frontend и Backend сервера
![[Materials/Pasted image 20250913115903.jpeg]]

Frontend сервер может генерировать статический контент
Backend 

http downgrade - переход на более низкую версию (всегда создает проблемы, но иногда используется)

### Архитектуры веб-приложений

**Монолит**
![[Materials/Pasted image 20250913120057.jpeg]]

"Большое, неподъемное", все начинающие сервисы начинаются с монолита, только потом он распиливается

В банках постоянно используется монолит, уйти от него тяжело.

**Микросервисная архитектура**

![[Materials/Pasted image 20250913120242.jpeg]]

**Сервис-ориентированная архитектура**
![[Materials/Pasted image 20250913120509.jpeg]]
похож на микросервис, но более выделенные сервисы

**Intercept Proxy**
![[Materials/Pasted image 20250913120613.jpeg]]

