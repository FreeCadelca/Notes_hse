![](./Materials/Lect8%20-%20Серверные%20уязвимости%20веб-приложений.%20Часть%205-1762268811073.jpeg)

# Insecure deserialization

> **Сериализация** - процесс преобразования сложных данных, таких как объекты и их поля, в более "плоский" формат, который можно отправлять и получать как последовательный поток байтов. Сериализация данных значительно упрощает:
> - запись сложных данных в межпроцессорную память, файл или бд
> - передачу сложных данных по сети между различными компонентами приложения или в вызове API

Важнейшим моментом является то, что при сериализации объекта его состояние также сохраняется. Другими словами, сохраняются атрибуты объекта и присвоенные им значения.

> **Десериализация** - это процесс восстановления потока байтов до полностью функциональной копии исходного объекта, в том же состоянии, в котором он был на момент сериализации. Логика веб-сайта может взаимодействовать с этим десериализованным объектом, как и с любым другим объектом.

Вид сериализованных данных
- бинарный (для изменения нужно писать код или использовать специальные инструменты)
- plaintext (для изменения достаточно знать структуру)
Корректный вид будет зависеть от языка программирования и библиотеки, используемой для сериализации данных

### Пример на Python

```python
import json
data = {"name": "Alice", "age": 30, "city": "London"}
json_string = json.dumps(data)
print("Serialized:", json_string)
deserialized_data = json.loads(json_string)
print("Deserialized:", deserialized_data["name"])
```

### Небезопасная десериализация

**Небезопасная десериализация** - ситуация, когда веб-сайт десериализаует контролируемые пользователем данные. Это потенциально позволяет злоумышленнику манипулировать сериализованными объектами для передачи вредоносных данных в код приложения

Можно даже заменить сериализованный объект объектом совершенно другого класса. Объекты любого класса, доступного приложению, будут десериализованы и созданы, вне зависимости от того, какой класс ожидался. По этой причине небезопасную десериализацию иногда называют уязвимостью "внедрения объекта".

Объект неожиданного класса может вызвать исключение. Однако к этому моменту ущерб может быть уже нанесен. Многие атаки, основанные на десериализации, завершаются до завершения десериализации. Это означает, что сам процесс десериализации может инициировать атаку, даже если функциональность веб-сайта напрямую не взаимодействует с вредоносным объектом. По этой причине веб-сайты, логика которых основана на строго типизированных языках, также могут быть уязвимы к этим методам.

Влияние:
- контроль над функционалом, связанным с сериализованным объектом
- **RCE**
- повышение привилегий, чтение файлов, DoS
- разнообразное в зависимости от функционала
Почти всегда будет нести катастрофический эффект

### Детектирование

- при наличии исходного кода: библиотеки, функции и классы, специфичные для конкретных языков программирования
- при анализе черным ящиком: обращать внимание на сериализованные данные согласно форматам, специфичных для конкретных ЯП

### Формат сериализации PHP

![](./Materials/Lect8%20-%20Серверные%20уязвимости%20веб-приложений.%20Часть%205-1762269129925.jpeg)

методы: serialize(), unserialize()

### Формат сериализации Java
- Бинарный
- Способы детектирвования:
	- "AC ED 00 05" in Hex
		"AC ED": STREAM_MAGIC. Обозначение протокола сериализации
		00 05: STREAM_VERSION. Версия
	- ="rO0" in Base64
	- Content-Type = "application/x-java-serialized-object"
	- "H4sIAAAAAAAAAJ" in gzip(base64)

Методы: класс java.io.Serializable, readObject(), InputStream

![](./Materials/Lect8%20-%20Серверные%20уязвимости%20веб-приложений.%20Часть%205-1762269222684.jpeg)

### Сериализация .Net

- бинарный
- способы детектирования:
	- AAEAAD (Hex).NET: BinaryFormatter
	- FF01 (Hex).NET: ViewState
	- /w (Base64).NET ViewState

![](./Materials/Lect8%20-%20Серверные%20уязвимости%20веб-приложений.%20Часть%205-1762269408781.jpeg)

.Net serialisation formatters

![](./Materials/Lect8%20-%20Серверные%20уязвимости%20веб-приложений.%20Часть%205-1762269447150.jpeg)

### Прочие форматы сериализации:
- py: pickle и производные (gASV в начале в base64, cPickle.loads, pickle.loads, \_pickle.loads, jsonpickle.decode)
- Ruby: marshal
- Node.js: node-serialize, serialize-to-js, funcster

### Атаки на небезопасную десериализацию

##### 1. Измена атрибута объекта

- позволяет влиять на логику приложения
- позволяет делать объединение с другими уязвимостями

![](./Materials/Lect8%20-%20Серверные%20уязвимости%20веб-приложений.%20Часть%205-1762269661220.jpeg)

##### 2. Изменение типа данных

- Позволяет влиять на логику приложения
- Будет работать только в свободно типизированных ЯП 

![](./Materials/Lect8%20-%20Серверные%20уязвимости%20веб-приложений.%20Часть%205-1762269669526.jpeg)

![](./Materials/Lect8%20-%20Серверные%20уязвимости%20веб-приложений.%20Часть%205-1762269743009.jpeg)

##### Изменение атрибута объекта с последующим влиянием на его жизненный цикл

- По сути тот же самый вектор, но ориентирован на жизненный цикл объекта
- Пример: указание ссылки на внутренний файл в качестве атрибута объекта и последующие удаление пользователя. При удалении вызовется деструктор объекта, который может пройтись по атрибутам и удалить файл по указанному пути
- также вектор может быть основан на вызове классических свойств объекта

> Магические методы - особое подмножество методов, которые не требуют явного вызова. Вместо этого они вызываются автоматически при возникновении определённого события или сценария. Магические методы - распространённая особенность ООП в различных языках. Иногда их обозначают префиксом или двойным подчеркиванием вокруг имени метода.

- Присутствуют во большинстве языков программирования, обладающих концепцией ООП
- Выполняются до того, как объект будет полностью создан (данные полностью десериализуются)
-  Являются мощнейшим инструментом для небезопасной десериализации

PHP Magic methods

![](./Materials/Lect8%20-%20Серверные%20уязвимости%20веб-приложений.%20Часть%205-1762269887053.jpeg)
![](./Materials/Lect8%20-%20Серверные%20уязвимости%20веб-приложений.%20Часть%205-1762269896573.jpeg)
![](./Materials/Lect8%20-%20Серверные%20уязвимости%20веб-приложений.%20Часть%205-1762269907184.jpeg)

Как можно использовать магические методы:
- реализация логики при инъекции произвольного объекта
- построение цепочки гаджетов

### Gadget chain

> Гаджет - фрагмент ***собственного*** кода приложения (либо использования в зависимостях), позволяющий атакующему реализовать некоторую цель.

- В одиночку гаджет редко представляет угрозу, однако, если использовать их цепочку (как ROP-chain в бинарной эксплуатации), то становится возможным достижение определённых мест (kick-off gadgets)
- При эксплуатации цепочки гаджетов не происходит инъекции нового кода - весь код уже в приложении. Атакующий контролирует только данные, которые передаются в указанную им цепочку
- В реальных приложениях проэксплуатировать небезопасную десериализацию без построения цепочки гаджетов практически невозможно

Способы построения gadget chain

- использование переподготовленных цепочек гаджетов. Для многих фреймворков есть уже исследованные цепочки гаджетов. Существуют инструменты для этого
	- ysoserial (Java) https://github.com/frohoff/ysoserial
	- ysoserial.net (.NET) https://github.com/pwntester/ysoserial.net
	- phpggc (PHP) https://github.com/ambionics/phpggc
- Использования документированных цепочек гаджетов: поиск информации в открытых источниках об известных цепочках в выбранном фреймворке выбранного языка программирования
- Построение цепочки гаджетов вручную. Сложный, времязатратный, но эффективный процесс
- **Важно:** уязвимость небезопасной десериализации заключается в десериализации данных, подконтрольных пользователю, а не наличие цепочки гаджетов в приложении

### Пример небезопасной десериализации в исходном коде

```php
<?php
	class PHPObjectInjection{
		public $inject;
		function __construct(){
		}
		function __wakeup(){
			if(isset($this->inject)){
				eval($this->inject);
			}
		}
	}
	if(isset($_REQUEST['r'])){
		$var1=unserialize($_REQUEST['r']);
		if(is_array($var1)){
			echo "<br/>".$var1[0]." - ".$var1[1];
		}
	}
	else{
		echo ""; # nothing happens here
	}
?>
```

Пример пейлоада: 
"O:18:"PHPObjectInjection":1:{s:6:"inject";s:17:"==system('whoami');==";}"

### PHAR десериализация

- PHP ARchive file (PHAR) - формат файла (архив)
- Может быть вызван при помощи протокола phar://path_to_file
- При таком обращении будет неявно производиться десериализация метаданных файла
- Можно сконструировать специальный phar-файл, содержащий полезную нагрузку в метаданных

```php
<?php
	class AnyClass {
	public $data = null;
	public function __construct($data) {
		$this->data = $data;
	}
	
	function __destruct() {
		system($this->data);
	}
}

// create new Phar
$phar = new Phar('test.phar');
$phar->startBuffering();
$phar->addFromString('test.txt', 'text');
$phar->setStub("\xff\xd8\xff\n<?php __HALT_COMPILER(); ?>");

// add object of any class as meta data
$object = new AnyClass('whoami');
$phar->setMetadata($object);
$phar->stopBuffering();
```

### Защита

- **не использовать десериализацию пользовательского ввода**
- контроль целостности сериализованных данных (нужно проверять ДО начала процесса десериализации)
- по возможности не использовать универсальные методы для десериализации, а писать собственные для необходимых классов (добавляет контроль теряемой информации)
- проверять тип данных после десериализации (может спасти от Type Juggling)
- Уязвимость не в наличии цепочек гаджетов, а в самом процессе десериализации пользовательских данных. Не нужно пытаться устранять цепочки гаджетов
- Использовать «безопасные» форматы сериализации (JSON, Protobuf, ...)

(Качественную защиту при использовании десериализации пользовательского ввода внедрить невероятно сложно)

### Доп. материал для insecure deserialize

- Небезопасная десериализация через использование уязвимостей повреждения памяти (Memory Corruption)
- JSON Insecure Deserialization Vulnerabilities (CVE-2017-7525, CVE-2017-17485, CVE-2019-12384, CVE-2020-36180, CVE-2020-9548)
- YAML Insecure Deserialization Vulnerabilities (Java, PyYAML, Ruby)

### Cheatsheets

https://swisskyrepo.github.io/PayloadsAllTheThings/Insecure%20Deserialization/

# File Upload Vulnerabilities

> Уязвимости загрузки файлов возникают, когда веб-приложение позволяет пользователям загружать файлы в файловую систему без достаточной проверки таких параметров, как имя, тип, содержимое или размер.

### Как это может выглядеть в исходном коде

```python
@app.route('/upload', methods=['POST'])
def upload():
	file = request.files['file']
	file.save('uploads/' + file.filename)
	return 'Uploaded!'
```

```java
@PostMapping("/upload")
public String upload(@RequestParam("file") MultipartFile file) {
	File dest = new File("uploads/" + file.getOriginalFilename());
	file.transferTo(dest);
	return "Uploaded!";
}
```

### Влияние

Зависит от двух факторов:
- какой аспект файла приложение некорректно проверяет (размер, тип, содержание и т д)
- какие ограничения накладываются на файл после его загрузки

- Удаленное исполнение кода (RCE)
- DoS (исчерпание ресурсов сервера)
- Перезапись чувствительных файлов
- Использование ресурсов системы
- Влияние на бизнес-логику приложения
- Client-Side атаки
- Эксплуатация уязвимостей обработки файлов (напр. XXE)

### File system routing

1. Фиксируется web root веб-сервера (/var/www/html)
2. Файлы приложения помещаются физически на файловую систему (/var/www/html/profile.php)
3. При обращении по пути веб-приложения происходит адресация к конкретному файлу (/profile.php -> /var/www/html/profile.php)

##### Что делает приложение, когда мы обращаемся к файлу?
1. Если файл статический - оно вернет его контент в нужном формате
2. Если файл исполняемый и веб-сервер сконфигурирован на исполнение подобных файлов - он исполнится
3. Если файл исполняемый и веб сервер не сконфигурирован на исполнение подобных файлов - скорее всего файл просто загрузится на ваше устройство

##### Важные HTTP заголовки в данном ключе:
- Content-Type - показывает формат, в котором данные возвращаются
- Content-disposition: attachment - указывает на то, что файл должен быть загружен, а не отображен в браузере/исполнен

### Атака

##### Исполнение произвольного кода через загрузку файла (веб-шелл)

![](./Materials/Lect8%20-%20Серверные%20уязвимости%20веб-приложений.%20Часть%205-1762286229934.jpeg)

##### Какие аспекты есть у файла при его загрузке?

Загружаемый файл построен из:
- Названия и расширения
- Содержания
- Content-Type (MIME-Type)
- File Type (magic bytes)
- \*Директория загрузки с определенными правами

На каждый из таких аспектов существуют механизмы проверки и варианты их обхода

### Обходы механизмов защиты

- Content-Type
`Content-Type: application/x-httpd-php` -> `Content-Type: image/jpeg`
- Ограничения исполнения в месте загрузки (File Path Traversal)
`shell.php` -> `../static/shell.php`
- Черные списки: 
	- перезапись конфигурации веб-сервера (`/etc/apache2/apache2.conf`, `.htaccess`, `web.config`)
	
	```
	AddType application/x-httpd-php .new_extension
	```
	
	```
	<staticContent>
	<mimeMap fileExtension=".some_ext"
	mimeType="application/json" />
	</staticContent>
	```
	- Обфускация
	`shell.php.jpg`, `shell.php.`, `shell.pHp`, `shell%2Ephp`, `shell%252Ephp`, `shell.phtml`, `shell.php;.jpg`, `shell.php%00.jpg`, `shell.p.phphp` + использование кодировок (utf8->ascii)
- Polyglot files (File Type bypass)
`exiftool -Comment="<?php echo 'START ' . file_get_contents('/secret') . ' END'; ?>" <IMAGE>.jpg -o polyglot.php`
- AV Bypass
Race Conditions

### Загрузка файлов через PUT

```http
PUT /images/exploit.php HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-httpd-php
Content-Length: 49
<?php echo file_get_contents('/path/to/file'); ?>
```

### Защита

- Использовать белые списки для проверки расширений
- Реализовать защиту от path traversal
- Переименовывать файлы после загрузки (избежание перезаписи)
- Не загружать файлы на постоянную файловую систему до полноценной проверки
- Использовать готовые безопасные фреймворки для загрузки файлов
- Проверять размер файла перед загрузкой
- Реализовать защиту от Client-Side атак в загруженных файлах
- Реализовать контроль доступа до загруженных файлов

### Cheatsheets

https://book.hacktricks.wiki/en/pentesting-web/file-upload/index.html

![](./Materials/Lect8%20-%20Серверные%20уязвимости%20веб-приложений.%20Часть%205-1762286948784.jpeg)
