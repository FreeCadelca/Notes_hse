### Серверные уязвимости веб-приложений. Часть 1: SQLi, NoSQLi

Серверная уязвимость - цель на сервер

### SQLi
- Уязвимость, позволяющая вмешиваться в запросы, которые приложение отправляет к своей базе данных. Это позволяет делать злоумышленнику что угодно с базой данных
`https://example.com/get-user?...`
```
select * from users
where user='' or 1=1--
```

**~~SQLmap~~**

пример уязы в коде: ... (Python)
```
import sqlite3
username = input("Enter username")
conn = sqlite3.connect(..)
```

Возможное влияние:
- Чтение чувствительной информации из бд
- Запись информации в бд
- изменение логики работы приложения
- RCE (remote code execution)
- ...

Этапы эксплуатации:
1. Детектирование
2. Определение типа SQLi
3. Получение информации о СУБД и используемом SQL-запросе
4. 1. ПОпытка исполнения кода/...

Детектирвание черным ящиком:
Ищем потенциальные места инъекций (параметры запроса), затем:
- Добавляем символы \', \'', ) в разных комбинациях и смотрим на ошибки и аномалии
- Вставляем конструкции SQL-синтаксиса и сравниваем с ожидаемым поведением
- **Вставляем лог конструкции OR 1=1 и OR 1=2**
- Используем time-based нагрузки
- Используем out-of-bound нагрузки

Почему опасно использовать нагрузки вида `'OR 1=1--`?
- мы не знаем, куда попадает пейлоад, поэтому она может попасть в небезопасную конструкцию (INSERT/DELETE) и мы снесём бд
- DOS
- Если приложение ожидает 1 строку - получаем False Negative срабатывание (она есть, но мы не нашли)

Вместо этого используем следующие конструкции:
```
MySQL: ...
```

Места инъекций в SQL-запросе (наиболее частые):
```
...
```
чаще всего WHERE

Разновидности:
- Error-based
- Boolean-based
##### Error-based SQLi

-приложение возвращает ...
видимая sqli, мы можем печатать вызовом ошибок. 

##### Boolean-based SQLI
- Оперерирование лог операторами SQL
- Может быть составной частью других типов
- ...
`username=admin'--&password=anything`
##### Union-Based SQLi
- На union конструкциях SQL в нагрузке, чтобы получать данные из других таблиц путем объединения с исходным запросом
- Видимая инъ
- Возможно, если исходный SQL запрос - SELECT
- Является лучшим способом доставать данные, т.к. данные получаются в чистом виде без сложных конструкций
- Единственная сложность - количество столбцов в UNION запросе...

При эксплуатации:
1. Определяем количество столбцов
	`UNION SELECT NULL`, `UNION SELECT NULL, NULL`, ...
	`ORDER BY 1--`, `ORDER BY 2--`, ...
2. Определить столбец, который возвращается в ответе приложения и определить его тип данных
	`UNION SELECT'asd',NULL--`, `UNION SELECT NULL,'asd'--`
3. Определить, какие таблицы (information_schema.tables) и столбцы (information_schema.columns) есть в бд
4. Достать необходимые значения
5. Бонус- можно использовать конкатенацию и выводить несколько столбцов
	`...||...`

```
GET /orders?type=1'UNION SELECT USERNAME ||'~'||
```

##### Time-based SQLi
- происходит вызов временных задержек в зависимости от истинности некоторого условия
- Обычно данные достаются посимвольно
- крайне затратный по времени метод. Стоит использовать только если больше ничего не работают
- Бинарный поиск и многопоточность спасают ситуацию
- К данному типу можно свести почти любой другой тип (а в каких случаях нет? - когда данные процедуры работают в многопотоке)

GET/page?id==1';SELECT CASE WHEN (username='admin' AND SUBSTRING(password,1,1)='a') THEN pg_sleep(10) ELSE pg_sleep(0) END FROM users--==...

##### Blind SQLi
- Приложение не возвращает вывода вне зависимости от поставления данных
- Из поведения приложения можно однозначно сказать, истинно или ложно SQL-условие, которое отправляет атакующий
- Как самостоятельный тип может существовать, если приложение содержит какие-то доп. символы/заголовки
- Очень часто включает в себя другие типы как подвтды, например time-baser, error-based

##### Stacked Queries
- Эксплуатация построенна на внедрении второго (произвольного) SQL-запроса после оригинального
- Позволяет встроить запрос другого типа (UPDATE после SELECT)
- Обычно  

##### Out-of-bound SQLi
- SQL запрос инициирует обращение по сети к подконтрольному серверу
- Можно использовать как blind-технику или извлекать данные напрямую
- Часто не будет работать в современных приложениях (почему? - потому что контейнезируют все современные приложения или прокся)
- Если работает, то может спасти, когда time-based и прочие типы не работают

##### Second Order SQLi
- Инъекция в SQL запросе происходит не напрямую, а после того, как данные были уже внедрены заранее
- Иными словами, сначала нагрузка сохраняется где-то в БД одним запросом, а затем, последующими запросами вставляется в уязвимый SQL-запрос
- Тип эксплуатации самой нагрузки может быть любой из упомянутых ранее
- Сложнее автоматизировать
- Практически не детектируется сканерами

##### SQLi Cheatsheets
[portswigger](https://portswigger...)
https://...

##### RCE в SQLi

Для каждой субд должны соблюдаться свои условия
- Если язык приложения php/jsp/подобные, то можно записать веб-шелл в файл на системе
- В MSSQL должен присутствовать xp_cmdshell и быть соответствующим ...
- СУБД Oracle можно создать и вызвать Java-процедуру
- PostgreeSQL
	- Использовать COPY TO / FROM PROGRAM
	- User-Defined Functions (UDF) (пишем функцию на С, компилируем и грузим в Postgres)
	- Large Objects (принцип похож на предыдущий, но используются структуры больших объектов. Сложность: нужно передавать файл частями и знать/указать идентификатор объекта)

##### Защита
- Санитизация, валидация управляющих символов (слабо)
- Строгое приведение типов
- **Prepared Statements** (однако, может работать не для всех частей запросов, например, названия таблиц, запросов, ORDER BY)
- **ORM**

### NoSQLi

- Уязвимость, с помощью которой злоумышленник может вмешаться в запросы, которые приложение делает к базе данных NoSQL

исходный код:

##### Возмодное влияние
- DoS
- ...

отличия от SQLi:
- Используются NoSQL субд
- Нет универсального стандарта - сильно зависит от СУБД и языка приложения
- Существует инъекция операторов (и не только синтаксиса)
- Некоторые NoSQL субд позволяют исполнять JS

Разновидности:
- syntaxis injection
	- Fuzz-payload: \'\"\` {; Foo ...}
	1. Посимвольный перебор значения
	2. Соответствие регулярному выражению
	3. "Угадывание" названий полей (различия в ответах)
- operator injection
	- Происходит, когда возможно использовать операторы запросов NoSQL для манипуляции запросами
	- Примеры операторов MongoDB:
	1. GET-запрос:
		```
		GET /login?username[$ne]=invalid HTTP/1.1
		Host:
		```
	
	2. ...
Детектирование и эксплуатация:
1. ...

Защита:
...
### OS Command injection

- позволяет 
