### Серверные уязвимости веб-приложений. Часть 1: SQLi, NoSQLi, OS cmd inj

Серверная уязвимость - цель на сервер
![|302x158](Materials/Pasted%20image%2020250920184935.jpg)

### SQLi

SQL инъекция - уязвимость, позволяющая вмешиваться злоумышленнику в запросы, которые приложение отправляет к своей базе данных. Это позволяет делать злоумышленнику что угодно с базой данных. 

`https://example.com/get-user?p=1'OR 1=1--` 
->
select * from users
where user=\' ==\' or 1=1--== \';

**~~SQLmap~~**

пример уязвимого кода (Python):
```
import sqlite3
username = input("Enter username")
conn = sqlite3.connect('example.db')
cursor = conn.cursor()
query = f"
	SELECT * 
	FROM users 
	WHERE username = '{username}'
	"
cursor.execute(query)
```

Возможное влияние:
- Чтение чувствительной информации из бд
- Запись информации в бд
- Изменение логики работы программы
- RCE (remote code execution)
- Чтение/запись системных файлов

##### Этапы эксплуатации:
1. Детектирование
2. Определение типа SQLi
3. Получение информации о СУБД и используемом SQL-запросе
4. Попытка исполнения кода/чтения/записи файлов
5. Попытка изменения логики приложения
6. Разведка БД -> получение/запись данных

##### Детектирование черным ящиком:
Ищем потенциальные места инъекций (параметры запроса), затем:
- Добавляем символы \', \'', ) в разных комбинациях и смотрим на ошибки и аномалии
- Вставляем конструкции SQL-синтаксиса и сравниваем с ожидаемым поведением
- **Вставляем логические конструкции OR 1=1 и OR 1=2 (опасно)**
- Используем time-based нагрузки
- Используем out-of-bound нагрузки

Почему опасно использовать нагрузки вида `'OR 1=1--`?
- мы не знаем, куда попадает пейлоад, поэтому она может попасть в небезопасную конструкцию (INSERT/DELETE) и мы снесём бд
- DOS
- Если приложение ожидает 1 строку - получаем False Negative срабатывание (она есть, но мы не нашли)

Вместо этого используем следующие [конструкции](https://tib3rius.com/sqli):
```
MySQL: 'OR IF((NOW() = SYSDATE()) SLEEP(1), 1)='0
PostgreSQL: ' OR (CASE WHEN ((CLOCK_TIMESTAMP() - NOW()) < '0:0:1') THEN (SELECT '1'||PG_SLEEP(1)) ELSE '0' END)='1
MSSQL: -
Oracle: ' OR ROWNUM = '1
SQLite: ' OR ROWID = '1
```

##### Места инъекций в SQL-запросе 
Наиболее частые:
#todo
Менее частые:

чаще всего WHERE

### Разновидности SQLi

##### Error-based SQLi
- приложение возвращает лог ошибок SQL в ответе (StackTrace)
- видимая sqli, мы можем печатать вызовом ошибок
- для эксплуатации нужно заставить приложение вернуть ошибку, содержащую нужные данные

Пример:
```
Xdd
```

##### Boolean-based SQLI
- Оперирование логическими операторами SQL
- Может быть составной частью других типов
- Как самостоятельный тип используется для влияния на логику и обхода авторизации
`username=admin'--&password=anything`
##### Union-Based SQLi
- На union конструкциях SQL в нагрузке, чтобы получать данные из других таблиц путем объединения с исходным запросом
- Видимая инъ
- Возможно, если исходный SQL запрос - SELECT
- Является лучшим способом доставать данные, т.к. данные получаются в чистом виде без сложных конструкций
- Единственная сложность - количество столбцов в UNION запросе...

При эксплуатации:
1. Определяем количество столбцов
	`UNION SELECT NULL`, `UNION SELECT NULL, NULL`, ...
	`ORDER BY 1--`, `ORDER BY 2--`, ...
2. Определить столбец, который возвращается в ответе приложения и определить его тип данных
	`UNION SELECT'asd',NULL--`, `UNION SELECT NULL,'asd'--`
3. Определить, какие таблицы (information_schema.tables) и столбцы (information_schema.columns) есть в бд
4. Достать необходимые значения
5. Бонус- можно использовать конкатенацию и выводить несколько столбцов
	`...||...`

```
GET /orders?type=1'UNION SELECT USERNAME ||'~'||
```

##### Time-based SQLi
- происходит вызов временных задержек в зависимости от истинности некоторого условия
- Обычно данные достаются посимвольно
- крайне затратный по времени метод. Стоит использовать только если больше ничего не работают
- Бинарный поиск и многопоточность спасают ситуацию
- К данному типу можно свести почти любой другой тип (а в каких случаях нет? - когда данные процедуры работают в многопотоке)

GET/page?id==1';SELECT CASE WHEN (username='admin' AND SUBSTRING(password,1,1)='a') THEN pg_sleep(10) ELSE pg_sleep(0) END FROM users--==...

##### Blind SQLi
- Приложение не возвращает вывода вне зависимости от поставления данных
- Из поведения приложения можно однозначно сказать, истинно или ложно SQL-условие, которое отправляет атакующий
- Как самостоятельный тип может существовать, если приложение содержит какие-то доп. символы/заголовки
- Очень часто включает в себя другие типы как подвтды, например time-baser, error-based

##### Stacked Queries
- Эксплуатация построенна на внедрении второго (произвольного) SQL-запроса после оригинального
- Позволяет встроить запрос другого типа (UPDATE после SELECT)
- Обычно  

##### Out-of-bound SQLi
- SQL запрос инициирует обращение по сети к подконтрольному серверу
- Можно использовать как blind-технику или извлекать данные напрямую
- Часто не будет работать в современных приложениях (почему? - потому что контейнезируют все современные приложения или прокся)
- Если работает, то может спасти, когда time-based и прочие типы не работают

##### Second Order SQLi
- Инъекция в SQL запросе происходит не напрямую, а после того, как данные были уже внедрены заранее
- Иными словами, сначала нагрузка сохраняется где-то в БД одним запросом, а затем, последующими запросами вставляется в уязвимый SQL-запрос
- Тип эксплуатации самой нагрузки может быть любой из упомянутых ранее
- Сложнее автоматизировать
- Практически не детектируется сканерами

##### SQLi Cheatsheets
[portswigger](https://portswigger...)
https://...

##### RCE в SQLi

Для каждой субд должны соблюдаться свои условия
- Если язык приложения php/jsp/подобные, то можно записать веб-шелл в файл на системе
- В MSSQL должен присутствовать xp_cmdshell и быть соответствующим ...
- СУБД Oracle можно создать и вызвать Java-процедуру
- PostgreeSQL
	- Использовать COPY TO / FROM PROGRAM
	- User-Defined Functions (UDF) (пишем функцию на С, компилируем и грузим в Postgres)
	- Large Objects (принцип похож на предыдущий, но используются структуры больших объектов. Сложность: нужно передавать файл частями и знать/указать идентификатор объекта)

##### Защита
- Санитизация, валидация управляющих символов (слабо)
- Строгое приведение типов
- **Prepared Statements** (однако, может работать не для всех частей запросов, например, названия таблиц, запросов, ORDER BY)
- **ORM**

### NoSQLi

- Уязвимость, с помощью которой злоумышленник может вмешаться в запросы, которые приложение делает к базе данных NoSQL

исходный код:

##### Возмодное влияние
- DoS
- ...

отличия от SQLi:
- Используются NoSQL субд
- Нет универсального стандарта - сильно зависит от СУБД и языка приложения
- Существует инъекция операторов (и не только синтаксиса)
- Некоторые NoSQL субд позволяют исполнять JS

Разновидности:
- syntaxis injection
	- Fuzz-payload: \'\"\` {; Foo ...}
	1. Посимвольный перебор значения
	2. Соответствие регулярному выражению
	3. "Угадывание" названий полей (различия в ответах)
- operator injection
	- Происходит, когда возможно использовать операторы запросов NoSQL для манипуляции запросами
	- Примеры операторов MongoDB:
	1. GET-запрос:
		```
		GET /login?username[$ne]=invalid HTTP/1.1
		Host:
		```
	
	2. ...
Детектирование и эксплуатация:
1. ...

Защита:
...
### OS Command injection

- позволяет 
