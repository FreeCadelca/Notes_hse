![](./Materials/Lect5%20-%20Серверные%20уязвимости-1759060394442.jpeg)

### Основные понятия

> **Идентификация** -  процедура, в результате выполнения которой для субъекта идентификации выявляется его идентификатор, однозначно определяющий этого субъекта в информационной системе

> **Аутентификация** - процедура проверки подлинности, например, проверка подлинности пользователя путём сравнения введённого им пароля с паролем, сохранённым в базе данных

> Авторизация - предоставление определенному лицу или группе лиц прав на выполнение определённых действий

Пример:
![](./Materials/Lect5%20-%20Серверные%20уязвимости-1759060557478.jpeg)

![](./Materials/Lect5%20-%20Серверные%20уязвимости-1759060587274.jpeg)
Ввод логина - идентификация
Аутентификация - проверка пароля+логина
Авторизация - вход в аккаунт

Сессии и JWT

| Критерий                    | Сессии                                           | Json Web Tokens                                          |
| --------------------------- | ------------------------------------------------ | -------------------------------------------------------- |
| Место хранения состояния    | Серверная память или хранилище (БД)              | Клиентская сторона (local storage)                       |
| Масштабируемость            | Требует синхронизации сессий между серверами     | Stateless                                                |
| Производительность          | Запросы к хранилищу для проверки сессии          | Быстрая проверка подписи токена без запросов к БД        |
| Межсерверное взаимодействие | Сложно использовать в микросервисной архитектуре | Идеально для микросервисов                               |
| Отзыв                       | Легко отозвать через сервер (удаление сессии)    | Сложнее отозвать (требуются черные списки, короткие TTL) |

### Атаки на аутентификацию

#### Аутентификация и факторы

Аутентификация имеет разные количества и типы факторов

1. Знание (Knowlege) - что-то, что ты **знаешь** (пароль, ответ на секретный вопрос)
2. Владение (Possession) - что-то, чем ты **владеешь** (телефон, физ токен)
3. Свойство (inherence) - что-то, что **является частью тебя** (биометрия, характер поведения)

Возможное влияние:
- захват аккаунта (Account Takeover, ATO)
- Кража ПД
- Повышение привилегий
- Повышение шансов на RCE

#### Password-based login: методы и атаки 
1. Использование слабых паролей и паролей по умолчанию
	![](./Materials/Lect5%20-%20Серверные%20уязвимости-1759063273752.jpeg)
	![](./Materials/Lect5%20-%20Серверные%20уязвимости-1759063303041.jpeg)
	Защита: 
	- проверка сложности пароля, 
	- смена паролей по умолчанию
	- ставить проверку на предыдущие 5 паролей
	- проверять список слитых паролей
2. Credential Stuffing - переиспользование пар логин-пароль
	Защита: регулярная смена паролей
3. Username Enumeratiion - возможность определить существование пользователя, исходя из:
	- Различных текстов ответа приложения
	- Различных кодов ответа
	- Незначительных опечаток в одинаковых ответах приложения
	- Разного времени ответа приложения
	![](./Materials/Lect5%20-%20Серверные%20уязвимости-1759063419937.jpeg)
	Защита:
	- Возвращение одинакового ответа вне зависимости от существования пользователя в системе
4. Перебор логиной/паролей (bruteforce)

| Метод защиты              | Вариант обхода                                                                                                                                                      |
| ------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Блокировка по ip          | - Сброс счетчика путем входа в валидный акк<br>- Маскировка настоящего ip (например, X-Forwarded-For)<br>- Использование распределенной системы перебора (**D**DoS) |
| Блокировка учётной записи | - Создает возможность User Enumeration<br>- Делает возможным множественную блокировку УЗ                                                                            |
| CAPTCHA                   | Эксплуатация мисконфигураций CAPTCHA (модификация, переиспользование, игнорирование и пр.)                                                                          |

5. "Умный" перебор - эксплуатация особенностей языков программирования и технологий, используемых в приложении
	![](./Materials/Lect5%20-%20Серверные%20уязвимости-1759063767028.jpeg)
	Примеры:
	- В некоторых случаях мы можем отправить не один пароль, а массив паролей, кадждый из которых будет проверять приложением
	- В GraphQL существуют алиасы, с помощью которых можно перебрать несколько значений одним запросом
6. Перебор в базовой аутентификации (Basic authentication)
	![](./Materials/Lect5%20-%20Серверные%20уязвимости-1759063861582.jpeg)
	Защита: отказаться от базовой аутентификации
7. Client-side aythentication
	Нужно отказываться от такого в принципе!

#### Мультифакторная авторизация: методы атаки
1. Слабый генератор OTP (one-time password)
	Слабый генератор
	```
	seed = 123123
	rand(seed) = a1
	rand(seed) = a1
	```
	Более надежный генератор
	```
	seed = 123123
	rand(seed) = a1
	rand(seed) = b2
	```
	Защита:
	- Использование надежных приложений (Google Auth) и функций для генерации OTP
2. Некорректное состояние сессии:
	Гость -> пройден 1 фактор -> пройдены оба фактора
	Защита: корректный контроль состояния сессии
3. Account hijack
	https\://example.com/2nd-stage?==id=2==
	Защита:
	- Привязка OTP к идентификатору
	- Изменение логики
4. Перебор OTP

| Метод защиты                             | Вариант обхода                                                    |
| ---------------------------------------- | ----------------------------------------------------------------- |
| Инвалидация временной сессии             | Автоматизация прохождения первого фактора                         |
| Инвалидация OTP после N неверных попыток | Запрос нового кода и перебор N первых кодов (вероятностный поход) |
| И прочие техники защиты и обх            | ода из атак на аутентификацию                                     |

5. Flood (когда можно вставить любой номер и высылать сколько угодно одноразовых кодов)
	Защита: Лимит на отправку OTP, потом таймаут

#### Прочие механизмы аутентификации: Кастомная аутентификационная cookie
1. Cookie guessing - подмена/угадывание/подбор
2. Insecure deserialization

#### Прочие механизмы аутентификации: восстановление пароля
1. Token guessing - слабая энтропия (нерандомный рандом) или логические ошибки
2. SQLi Ultimate Power - легкий ATO через SQLi (Почему? - Если есть функционал восстановления - значит есть токен => через sqli вытаскиваем токен в чистом виде, они редко защищены)
3. Host Header attacks
4. Exotic exploits (e.g. dangling markup injection)
5. User enum
6. Flood

#### Прочие механизмы аутентификации: смена пароля
1. Broken access control (смена пароля другому пользователю)
2. Logic Flaws (перебор пароля без блокировки УЗ)
3. Prototype Pollution (Server-Side)
4. Mass Assignment (мы можем при смене добавить смену роли, а также других полей)

#### Прочие механизмы аутентификации: кастомная CAPTCHA
1. CAPTCHA guessing (угадывание капчи)
2. CAPTCHA modify (замена значения на необходимое)
3. CAPTCHA reuse (переиспользование)
4. CAPTCHA DoS (возможность испортить единичную капчу или группу по идентификатору, делая невозможным ее правильный ввод)

#### Прочие механизмы аутентификации: регистрация
1. Mass Assignment
2. Prototype Pollution (Server-Side)

### Сессии

> Сессия - это механизм, который позволяет серверу сохранять информацию о взаимодействии с конкретным пользователем в течение определенного периода времен (пока пользователь активен на сайте)

Проще говоря, это способ "помнить" пользователя

На стороне сервера, идентификатору сессии присваиваются атрибуты (свойства, состояния)
![](./Materials/Lect5%20-%20Серверные%20уязвимости-1759065182098.jpeg)

#### Атаки на сессии

**Sessioon Fixation** - позволяет злоумышленнику перехватить действующий сеанс управления идентификатором сеанса веб-приложения. Причина уязвимости в способе управления идентификатором сеанса веб-приложения.
- Атакующий может получить id сессии и отправить жертве. После того, как жертва аутентифицируется в системе, атакующий получит валидную сессию жертвы
![](./Materials/Lect5%20-%20Серверные%20уязвимости-1759065291278.jpeg)
Атака реализуется, если
1. Приложение не выдает нового id сессии после успешной аутентификации пользователя
2. Атакующий может выставить жертве id сессии (через client-side уязвимость или иными способами)
Защиты: выдача нового SessId после аутентификации

**Session Puzzling** - уязвимость, которая возникает, когда переменная сеанса приложения используется для более одного назначения
- В результате эксплуатации атакующий получает доступ к свойтсвам сессии другого пользователя
![](./Materials/Lect5%20-%20Серверные%20уязвимости-1759065348245.jpeg)
Защита: использовать переменную сеанса только для одного назначения

**Imposter Session Invalidation**
- После выхода из аккаунта сессия остается валидной
- Если сессия будет украдена, то нет способа сделать ее невалидной кроме прямого вмешательства
Защита: корректная инвалидация сессии после выхода из аккаунта или по истечении времени

### Json Web Tokens (JWT)

> JSON Web Tokens (JWT) - стандартизированный формат для передачи криптографически подписанных данных json между системами. Теоретически они могут содержать любые данные, но чаще всего используются для передачи информации "claims" о пользователях в рамках механизмов аутентификации, управления сеансами и контроля доступа

![](./Materials/Lect5%20-%20Серверные%20уязвимости-1759066537539.jpeg)

#### Структура
1. Заголовок
2. Тело
3. Криптографическая подпись

![](./Materials/Lect5%20-%20Серверные%20уязвимости-1759066576907.jpeg)

#### JWT vs JWS vs JWE

![](./Materials/Lect5%20-%20Серверные%20уязвимости-1759066863918.jpeg)

**JWT** (Json Web Token)
- Базовый формат передачи данных

**JWS** (Json Web Signature)
- Стандарт подписи JWT при помощи секретного ключа
- **Обычно имеют в виду именно это, когда говорят о jwt**

**JWE** (Json Web Encryption)
- Стандарт шифрования Payload-части
- Обычно имеет формат `header.encrypted_key.iv.ciphertext.tag`

#### Симметричные и ассиметричные алгоритмы подписи
- Симметричный (HS256 - HMAC+SHA256) - один ключ используется и для подписи, и для проверки подписи
![](./Materials/Lect5%20-%20Серверные%20уязвимости-1759070405663.jpeg)
- Ассиметричный (RS256 - RSA+SHA256) - закрытый ключ используется для подписи, открытый - для проверки подписи
![](./Materials/Lect5%20-%20Серверные%20уязвимости-1759070424333.jpeg)

#### Access и Refresh токены
- Способ управления "долгосрочной" авторизацией пользователя
- В UI обычно будет применён после нажатия кнопки "запомнить меня"
- Идея: при аутентификации выдаётся два токена: Access и Refresh
- Токены помещаются в разные места и имеют разный срок жизни
- Access Token имеет имеет короткий срок жизни и используется для авторизации
- Refresh Token имеет долгий срок жизни и используется для получения новой пары Access и Refresh-токенов
- Утечка Refresh-токена несет серьезный ущерб

![](./Materials/Lect5%20-%20Серверные%20уязвимости-1759070928576.jpeg)

#### Атаки на JWT: влияние
- Сильный контроль над приложением
- Обход аутентификации
- Повышение привилегий внутри приложения
- ATO (account takeover)
- Представление другим пользователем
- Другие векторы атак

#### Атаки на JWT

1. Отсутствие проверки подписи
	- Вместо метода verify() используется decode()
	- Подпись не проверяется
	- Можно записывать любые данные
	Защита:
	- Проверять подпись JWT

2. Поддержка алгоритма none
	- Приложение полностью доверяет токену от клиента (Принцип JWT)
	- Приложение не ограничивает используемые алгоритмы
	- Происходит замена на алгоритм none и подпись "отрезается", оставляя при этом завершаюзую точку
	![](./Materials/Lect5%20-%20Серверные%20уязвимости-1759071095811.jpeg)
	Защита:
	- отключение none алгоритма

3. Перебор ключей HS256
	- Алг HS256 - симметричный
	- Если используется слабый ключ, его можно эффективно подобрать
	- `hashcat -a O -m 16500 <jwt> <wordlost>` (брут)
	- `hashcat -a O -m 16500 <jwt> <wordlost> --show`
	Защита: использовать надёжные ключи

#### JWK, JKU, KID
- JWK - **J**son **W**eb **K**ey - формат представления ключа в json формате
- JKU - **J**son web **K**ey set **U**RL - ссылка, по которой можно полуить множество ключей и выбрать из них необходимы
- KID - **K**ey **ID** - идентификатор, позволяющий однозначно определить ключ из множества. В некоторых случаях позволяет указать путь до файла с ключом

#### Атаки на JWT

1. Использование самоподписанного ключа (jwk)
	1. Приложение использует ассиметричный алгоритм RS256
	2. Атакующий генерирует пару ключей
	3. Атакующий подписывает JWT собственным приватным ключом, а публичный помещает в токен в jwk
	4. Приложение использует ключ из jwk для проверки подписи => доверяет токену
	Защита - использовать белый список публичных ключей для проверки

2. Использование самоподписанного ключа (jku)
	1. Приложение использует ассиметричный алгоритм RS256
	2. Атакующий генерирует пару ключей
	3. Атакующий подписывает JWT собственным приватным ключом, **а публичный помещает в токен в jwk set на своем сервере**
	4. Параметр jku указывается ссылка на JWK set, расположенный по URL из jku для проверки подписи => доверяет ему, а также изменяется kid
	Защита - принимать ключи только из доверенных источников

3. Использование самоподписанного ключа (kid)
	1. Приложение использует симметричный алгоритм (HS256)
	2. В значение KID можно указать путь до файла
	3. Атакующий может подписать токен любым файлом, если знает его содержимое
	4. Можно использовать /dev/null и подписать пустым ключом
	5. Также, возможна эксплуатация SQLi через этот параметр
	Защита: не позволять принимать произвольный путь; защищаться от sqli

4. Algorithm confusion
	Идея: смена ассиметричного алгоритма на симметричный. В качестве подписи использовать публичный ключ.
	Этапы эксплуатации:
	1. Получение публичного ключа:
		-  в публично доступных директориях
		![](./Materials/Lect5%20-%20Серверные%20уязвимости-1759072457877.jpeg)
		-  вычислить на основе выданных токенов
		`docker run --rm -it portswigger/sig2n <token1> <token2>`
		`https://github.com/silentsignal/rsa_sign2n (jwt_forgery.py)`
	2. Перевод в необходимый формат (JWK, X.509 PEM, и т.д.) - ключ должен побайтово совпадать с имеющимся на сервере
	3. Создание JWT с alg HS256, подпись токена полученным ключом
	Защита: 
	- проверка соответствия используемому алгоритму

#### JWT Invalidation

Так как JWT - Stateless (не имеет состояния на стороне сервера), существуют проблемы в его инвалидации (прекращение срока действия)

Некоторые способы
- Указание очень короткого TTL
- Черный список невалидных токенов
- Механизмы инвалидации токенов по id (нужны триггеры, например, повторное использование refresh-токена)
- Смена ключа подписи (радикальный метод)