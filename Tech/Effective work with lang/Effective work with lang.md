### Передача аргументов (по значению, по ссылке, константной ссылке)

+

### Оптимальная передача объектов (move semantics, RVO/NRVO)

RVO - Return Value Optimization
Когда возвращаемое значение создается прямо в операторе return
```cpp
C f() { return C(); }
```
В таких ситуациях компилятору легче выполнить оптимизацию, чем в случае с NRVO.

NRVO - вместо создания `local_variable` компилятор сразу создаст `result` конструктором по умолчанию в точке вызова функции `f()`. А функция `f()` будет выполнять действия сразу с переменной `result`. То есть в этом случае не будет вызван ни конструктор копии, чтобы скопировать `local_variable` в `result`, ни деструктор `local_variable`

```cpp
C f() {  
	C local_variable;  
	// Действия с local_variable  
	return local_variable;
}

C result = f();
```

"Move семантика экономит ресурсы за счёт перемещения временных объектов. RVO/NRVO минимизируют создание временных объектов при возврате значений."

### Исключения

- throw/catch/try
- Желательно кидать исключения по **ссылке на const**.
- **noexcept** важен для безопасности перемещений и оптимизаций.
- Не бросать исключения в деструкторах!

### Работа с сырыми указателями
- Избегать `new/delete` напрямую.
- Использовать умные указатели: `std::unique_ptr`, `std::shared_ptr`, `std::weak_ptr'.
- Сырые указатели допустимы **только для неприватного владения** (non-owning).

Сырые указатели не должны владеть ресурсами. Для управления памятью нужно использовать RAII и умные указатели.

### Виды конструкторов (default, copy, move, explicit)

`type&` - аргумент обязательно lvalue
`const type&` -  аргумент может быть как lvalue, так и rvalue
`type&&` - аргумент может быть только rvalue

| Тип конструктора     | Описание                    |
| -------------------- | --------------------------- |
| Default              | Без параметров              |
| Copy                 | `T(const T&)`               |
| Move                 | `T(T&&)`                    |
| Explicit             | Запрещает неявные конверсии |
| Destructor           | Завершает объект            |
| Assignment operators | `copy=` и `move=`           |

В классе есть конструкторы: по умолчанию, копирования и перемещения. `explicit` предотвращает нежелательные неявные преобразования.

### Когда вызываются специальные (магические) методы класса - жизненный цикл объекта

**"Rule of Three/Five/Six":**
- Если нужно переопределить одно из:
    - Деструктор
    - Копирующий конструктор
    - Копирующий operator=
- то вероятно нужно и остальные.

**Rule of Five** дополняет move-семантикой:
- Move-конструктор
- Move operator=

**Когда вызываются:**

|Событие|Метод|
|---|---|
|Создание без параметров|Default ctor|
|Копирование|Copy ctor|
|Присваивание|Copy operator=|
|Перемещение|Move ctor|
|Перемещающее присваивание|Move operator=|
|Уничтожение|Destructor|
