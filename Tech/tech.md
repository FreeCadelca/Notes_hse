### [Основы языка и STL](Basics/Basics.md) +
- Базовые контейнеры STL
- Как утроен вектор и как работает push_back
- map vs unordered map
- reserve vs resize
- Конкатенация строк и sting bulder
- Безопасная работа с подстроками без копирования - string_view
- Доступ к несуществующему индексу
- Шаблоны - основы generic-программирования


### [Memory](Memory/Memory.md) +-
- Из чего состоит память программы (stack, heap)
- Выравнивание памяти *
- Умные указатели: unique_ptr, shared_ptr, weak_ptr *
- Идиомы RAII, PIMPL (pointer to implementation) *-
- Forward declaration *

### [ООП](OOP/OOP.md)  
- Таблица виртуальных функций

Используется для реализации **полиморфизма во время выполнения (run-time polymorphism)**.
Если в классе есть хотя бы **одна виртуальная функция**, компилятор добавляет скрытый указатель `vptr` на таблицу виртуальных функций (`vtable`).
При вызове виртуальной функции используется `vtable` для выбора правильной реализации (динамический dispatch).
Размер объекта увеличивается на размер указателя `vptr`.

Таблица виртуальных функций — это механизм реализации динамического полиморфизма. Она позволяет вызывать методы производного класса по указателю на базовый через `vptr`.

- Виртуальный деструктор

Нужен в базовом классе, если есть **наследование и работа через указатель/ссылку на базовый класс**.    
Без виртуального деструктора произойдёт **утечка памяти**, так как будет вызван **только деструктор базового класса**.
```cpp
class Base {
public:
    virtual ~Base() {} // обязательный virtual
};

class Derived : public Base {
public:
    ~Derived() { /* освобождение ресурсов */ }
};
```
Виртуальный деструктор обязателен в полиморфной иерархии, чтобы при удалении через указатель на базовый класс корректно вызывался деструктор наследника


- Ромбовидное наследование и решение

При ромбовидном наследовании базовый класс дублируется. Решение — виртуальное наследование, оно создаёт единственный общий экземпляр базового класса.

- Константные методы

Означают, что метод не изменяет состояние объекта.
Они могут вызываться у `const` объектов.
Гарантируют безопасность и улучшает дизайн API.

```cpp
class Point {
public:
    double getX() const { return x; }  // const метод
private:
    double x;
};
```
Константные методы помечены как `const` и гарантируют, что они не модифицируют объект. Такие методы можно вызывать у `const` объектов.
### [Многопоточность и параллелелизм](Multithreading%20and%20parallelism/Mulrithreading%20and%20parallelelism.md) +
- Механизмы синхронизации (мьютексы, атомики, condition_variable)
- future/promise - работа с асинхронностью
- гонки данных (Data Race, Race Condition)
- std::thread, корутины (stackless/stackfull), fibers - модели исполнения

### [Эффективная работа с языком](Tech/Effective%20work%20with%20lang/Effective%20work%20with%20lang.md) +
- Передача аргументов (по значению, по ссылке, константной ссылке)
- Оптимальная передача объектов (move semantics, RVO/NRVO)
- Исключения
- Работа с сырыми указателями
- Виды конструкторов (default, copy, move, explicit)
- Когда вызываются специальные (магические) методы класса - жизненный цикл объекта