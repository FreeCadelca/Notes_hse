# Задача детекции

Классифицировать объекты и сказать, где они именно есть

![](./Materials/Lect6%20-%20Детекция-1760004442210.jpeg)

- перебирать все прямоугольники очень долго
- не очень понятно, что такое хороший прямоугольник
- прямоугольники разного размера, усложняется классификация

### Non-maximum supression

- модель выдаёт для класса k список прямоугольников с уверенности
- проходим в порядке уменьшения уверенности
- для каждого прямоугольника удаляем все последующие, с которыми Intersection over Union (IoU) > 0.5

Это post-processing часть

![](./Materials/Lect6%20-%20Детекция-1760004850458.jpeg)

Мы не берем прямоугольник с наибольшей уверенностью, т.к. в случае двух одинаковых машинок на разных частях картинки мы забудем про все машины кроме одной, а нам нужно выделить два и более разных элемента одного класса

А как именно нейронка узнает про прямоугольники?

### Метрики качества

- Модель выдаёт для класса k список прямоугольников с уверенностями
- Считаем прямоугольники корректными, если 

![](./Materials/Lect6%20-%20Детекция-1760005164624.jpeg)

- Строим PR-кривую, считаем под ней площадь, получаем Average Precision
- Усредняем по всем классам, получаем mAP (mean AP)
- Раньше t = 0.5, сейчас скорее t=0.75 (если чуть чуть требовательны), t=0.95 (в современных моделях)

PR-кривая:

![](./Materials/Lect6%20-%20Детекция-1760005310105.jpeg)

- Левая точка - (0, 1)
- Правая точка - (1, r)
- Для идеального классификатора проходит через (1, 1)
- AUC-PRC - площадь под PR-кривой

precision - насколько можно доверять модели
recall - 

![](./Materials/Lect6%20-%20Детекция-1760005433027.jpeg)

правая лучше, чем левая, потому что площадь больше и сильнее "тянется" к (1, 1)

### Two-shot detection

Будем решать задачу в два этапа:
1. Находим "кандидатов" - прямоугольники, где скорее всего что-то есть
2. Классифицируем эти прямоугольники

### R-CNN

![](./Materials/Lect6%20-%20Детекция-1760005566854.jpeg)

есть входная картинка, давайте на входной картинке найдем 2 тысячи прямоугольников

потом будем сжимать эти прямоугольники и скармливать их CNN. На выходе делаем классификацию

Как генерировать прямоугольники?

Генерация кандидатов
- Внешние
- 

![](./Materials/Lect6%20-%20Детекция-1760005715793.jpeg)

Для извлечения признаков используем выходы AlexNet (в 2013 году), классифицируем прямоугольники на SVM (загоняем 4096 выходов туда)

Проблемы:
- Не end-to-end
- Генерация кандидатов может быть очень сложной
- Свёрточная сеть практически не настраивается под данные
- Долго (много признаков, много классификаторов)

Fast R-CNN

![](./Materials/Lect6%20-%20Детекция-1760006035916.jpeg)

Теперь мы забываем о существовании SVM и используем одну CNN

Мы можем выделить участок изображения, обрамлённый прямоугольником. Делаем хитрый RoI (region of interest) Pooling, который будет пуллить только интересующую нас область.

Теперь для конкретного кандидата предсказываются вероятности классов и 4 поправки к размерам прямоугольника

RoI:

![](./Materials/Lect6%20-%20Детекция-1760006235386.jpeg)

Прямоугольник задается центром + ширина + высота. Редко - двумя точками

Loss

![](./Materials/Lect6%20-%20Детекция-1760006612564.jpeg)

Есть Loss классификации $L_{cls}(p, u)$ - кросс-энтропия. А вторая часть - коэф лямбда (регуляризация), индикатор наличия объекта в области и $L_{loc}(t^u, v)$ - комбинация MAE и MSE, которая смотрит, насколько далек от правильного прямоугольника (разметил человек) наш выданный + поправки модели

![](./Materials/Lect6%20-%20Детекция-1760007112988.jpeg)

плохо то, что большее время уходит только на генерацию прямоугольников

Faster R-CNN

![](./Materials/Lect6%20-%20Детекция-1760007223728.jpeg)

а давайте перебросим генерацию прямоугольников в нейронку, будем делать это не фильтром собеля

Region Proposal Network
- Берём последний тензор из свёрточной сети
- Применяем свёрточный слой 3х3  с большим количеством каналов (256 или 512)
- Для каждой точки берём 9 прямоугольников с разными длинами сторон и соотношением сторон
- Для каждого предсказываем, есть ли там объект и 4 поправки к сторонам

![](./Materials/Lect6%20-%20Детекция-1760007341370.jpeg)

Всё обучается совместно, оптимизируем сумму 4 функций потерь:
- Классификация "есть ли объект" в RPN
- Регрессия для корректировки прямоугольника в RPN
- Классификация на K классов в основной модели
- Регрессия для корректировки прямоугольника в основной модели

на этапе применения:
- Выделяем самые уверенные регионы из RPN
- ...

![](./Materials/Lect6%20-%20Детекция-1760007464232.jpeg)

![](./Materials/Lect6%20-%20Детекция-1760007493733.jpeg)

### One-shot detection

![](./Materials/Lect6%20-%20Детекция-1760007563667.jpeg)

Мы хотим делать real-time detection. Пока что выходит только 5фпс

Давайте объединим этапы в один

### Архитектура Yolo

![](./Materials/Lect6%20-%20Детекция-1760007640626.jpeg)

DarkNet - наследник resNet

Мы предсказываем B прямоугольников (центр, w, h и obj score) + C классов

- Разбиваем изображение на S\*S блоков
- Для каждого блока предсказываем B прямоугольников
- ...

![](./Materials/Lect6%20-%20Детекция-1760007789218.jpeg)

![](./Materials/Lect6%20-%20Детекция-1760007824873.jpeg)

Очень быстро, но не так качественно, как Faster R-CNN

---
SSD (Single-shot detector) - архитектура, соперничающая с YOLO

RetinaNet
YOLOv{1-13}


![](./Materials/Lect6%20-%20Детекция-1760008015647.jpeg)

Идентификация объектов

Labeled Faced in the Wild
- Около 13к фотографий
- Около 6к человек

MegaFace (4.7 млн, 700к человек, ...)

Дообучение
![](./Materials/Lect6%20-%20Детекция-1760008347788.jpeg)

Если данных совсем мало:
- Берем модель из другой задачи
- Заменяем последний слой на слой с нужным числом выходов
- Обучаем только его
- По сути, это обучение линейной модели

Здесь неизбежно возникает проблема: если зарегистрировался новый пользователь, то нужно добавлять выход и всё переобучать

DeepFace
![](./Materials/Lect6%20-%20Детекция-1760008456976.jpeg)

Делаем не классификацию, а эмбеддинг (репрезентативные вектора)

- Обучаем некоторую архитекстуру для классификации (число классов = число людей в данных)
- Используем выходы предпоследнего слоя как признаковое описание изображения
- Признаки нормализируются (чтобы норма была единичной)
- Считаем близость векторов по какой-нибудь метрике

Можно сравнить расстояние с порогом, чтобы идентифицировать человека.

FaceNet
- Почему бы в явном виде не обучать представления изображения так, чтобы фотографии одного человека...

![](./Materials/Lect6%20-%20Детекция-1760008931571.jpeg)

![](./Materials/Lect6%20-%20Детекция-1760008723524.jpeg)

якорь - фотка
негатив - другая фотка (другого человека)
позитив - тот же чел, но повернутый

Максимизируем расстояние между негативным и якорем, и минимизируем между позитив и якорем

Триплетная и попарная ошибка...

